# 计算机网络

## socket通信流程

socket是”打开—读/写—关闭”模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的

服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket

服务器为socket绑定ip地址和端口号

服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开

客户端创建socket

客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket

服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入阻塞状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求

客户端连接成功，向服务器发送连接状态信息

服务器accept方法返回，连接成功

客户端向socket写入信息

服务器读取信息

客户端关闭

服务器端关闭



![image-20210301144729061](https://i.loli.net/2021/03/01/vOS4m1EobKsIPxw.png)







## 常见缩写

### RTT

往返时间 RTT (round-trip time) 表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。

### MSS

最大字段长度 MSS (Maximum Segment Size)，是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段，所以，MSS 是“TCP 报文段长度减去 TCP 首部长度”。

### MSL

`MSL`：报文最大生存时间，报文在网络上存在的最长时间，TCP连接必须经过时间2MSL后才真正释放掉。Windows默认MSL为2分钟。

https://blog.csdn.net/syzdev/article/details/105495239





## IO多路复用

![image-20210722102642137](https://i.loli.net/2021/07/22/NcKJMj1FEqQIAsw.png)



### BIO缺陷

blocking IO

作为服务端开发，使用Socket绑定端口号后，会监听该端口号，调用accpet函数等待客户端的连接，accept函数会阻塞当前进程，当我们收到客户端发来的connect请求后，accept函数返回，双方可以使用read/write函数进行通信，但是读写函数都是会阻塞当前进程的，一般客户端只有一个的时候，这样处理是OK，客户端数量不多的情况下，我们可以使用多线程解决，但是当客户端数量较多，如1万个客户端，就需要开启1万个线程，浪费资源。



### NIO

NIO是非阻塞的，可以用一个线程去检查n个socket



### Select工作原理

每次调用select函数，需要传递需要检查的socket集合，其实就是需要检查的fd（文件描述符）集合

select函数被调用中，回去检查内存中socket套接字的状态，如果有就绪的socket就直接返回，不会阻塞当前线程，如果fd集合中没有socket处于就绪状态，select会阻塞当前调用线程，直到某个socket有数据后，才唤醒线程。



### select监听socket数量1024

fd集合是一个bitmap位图结构，默认长度是1024个bit，想要修改长度非常麻烦，需要重新编译操作系统



### select是如何知道某个socket就绪

select函数第一遍轮询没有发现处于就绪状态的socket后，它就会把当前进程保留到每个需要检查的socket的等待队列中，

然后当前线程会被阻塞，处于挂起状态。



当客户端向服务端写入数据后，数据通过网线到网卡，网卡再到DMA，直接将数据写到内存中，整个过程，CPU是不参与的，当传输完成后，他就会触发网络数据传输完毕的中断程序，中断程序它会把cpu正在执行的进程给顶掉，然后cpu就会执行咱这个中断程序的逻辑（将数据送入输入缓冲区，唤起进程）

1. 对应的逻辑是：根据内存中的数据包，然后分析出来数据包是哪个socket的数据，
2. 同时tcp/ip它又是保证传输的时候是有端口号的，然后根据端口号就能找到对用的socket实例，找到socket实例以后，就会把数据导入到socket读缓冲里面
3. 导入完成以后，它就开始去检查socket等待队列，看是不是有等待者，如果有等待者的话，就会把等待者移动到工作队列里面去，中断程序到这一步就执行完了
4. 这样咱们的进程就又回到了工作队列，又有机会获取到cpu时间片了



然后当前进程执行的`select`函数再次检查，就会发现这个就绪的`socket了`,就会给就绪的`socket`的`fd`文件描述符打标记，然后`select`函数就执行完了，后面的事情就是轮询检查每一个socket的fd是否被打了标记，然后就是处理被打了标记的socket就ok了



每一次调用select(), 内核首先需要遍历监听socket, 唤醒后内核需要遍历移除等待队列中进程，而用户进程需要遍历查找哪些socket有数据，Select 之所以多次轮询是因为它无法知道事件发生时有哪些socket 产生了数据， epoll 的设计则解决了这个问题。



### poll和select区别

- select 用的是bitmap ，它表示需要检查的socket集合
- poll 使用的是数组结构，表示需要检查的socket集合（主要是为了解决socket监听长度超过1024的`socket`的限制）



### epoll产生原因

select 和 poll 函数它的返回值都是int整型值，只能代表有几个socket就绪或者有错误了，它没办法表示具体是哪个socket就绪了，这就导致了程序被唤醒以后，还需要新的一轮系统调用去检查哪个socket是就绪状态的，然后再进行socket数据处理逻辑。（read/write函数设计到从读缓存写缓存拷贝写入数据的过程，涉及到内核态和用户态的切换）

select 和 poll 函数，这两系统函数每次调用都需要我们提供给它所有的需要监听的socket文件描述符集合，而且主线程是死循环调用select/poll函数的,这里面涉及到用户空间数据到内核空间拷贝的过程
咱们需要监听的socket集合，数据变化非常小
每次就一到两个socket_fd需要更改，但是没有办法，因为select和poll函数，只是一个很单纯的函数
它在kernel层面，不会保留任何的数据信息，所以说每次调用都进行了数据拷贝



### epoll实现原理

- epoll 函数

  在内核空间内，它有一个对应的数据结构去存储一些数据，这个数据结构其实就是eventpoll对象

  - 这个`eventpoll` 可以通过一个系统函数`epoll_create()`函数去创建的

- 创建完成之后，系统函数返回一个`eventpoll`对象的id，相当于我们在内核空间开辟了一小块空间，并且我们也知道这块空间的位置

**先说下eventpoll 的数据结构：三块重要的区域**

- 一块是存放**需要监听的socket_fd描述符列表**
- 另一块就是**就绪列表，存放就绪状态的socket信息**
- eventpoll 还有一块空间是`eventpoll` 的**等待队列，这个等待队列保存的就是调用`epoll_wait`的进程**
- **另外呢还提供了两个函数，一个是`epoll_ctl`函数，一个是`epoll_wait`函数**
- **其中存放的socket集合信息采用的是红黑树的数据结构**，socket集合信息经常用增删改查的，这种红黑树再适合不过了，保持了时间复杂度为O(logN)



**epoll_ctl()**

- 它可以根据`eventpoll-id`去增删改内核空间上`eventpoll` 对象的检查列表（socket信息），每收到一个连接，就使用epoll_ctl函数增加一个fd到检查列表中

  ev.data.fd = accept(sockfd,(struct sockaddr*)&client, (socklen_t*)&addrlen);
  ev.events = EPOLLIN;
  epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &ev); 



epoll_wait() 

它主要的参数是eventpoll-id 表示此次系统调用需要检测的socket_fd集合，是eventpoll 中已经指定好的那些socket信息
epoll_wait 默认情况下会阻塞系统的调用线程，直到eventpoll 对象中关联的某个或者某些个socket就绪以后，epoll_wait函数才会返回
返回值是Int类型的
返回0，表示没有就绪的socket
返回大于0，表示有几个就绪的socket
返回-1表示异常

返回后，不需要轮训遍历所有fd，epoll_wait有一个参数是events，里面包含了收到数据的fd，直接从fd中读取数据即可

```c++
while(1){
  	puts("round again");
  	auto nfds = epoll_wait(epfd, events, 5, 10000);
	

	for(i=0;i<nfds;i++) {
			memset(buffer,0,MAXBUF);
			read(events[i].data.fd, buffer, MAXBUF);
			puts(buffer);
	}

  }


```



### epoll_wait获取就绪的socket

epoll_wait() 返回值是Int类型的

返回0，表示没有就绪的socket
返回大于0，表示有几个就绪的socket
返回-1表示异常
那么获取就绪的socket是怎么实现的呢？

epoll_wait 函数，调用的时候会传入一个epoll_event事件数组指针
epoll_wait 函数正常返回之前，会把就绪的socket事件信息拷贝到这个数组指针里头
这样返回到上层程序，就能通过这个数组拿到就绪列表

### 

### epoll_wait 可不可以设置成非阻塞的

默认epoll_wait 是阻塞的
它有一个参数，表示阻塞时间的长度，如果这个参数设置为0，表示这个epoll_wait 是一个非阻塞调用的
每次调用都会去检查就绪列表



### eventpoll 对象就绪列表的维护

select函数调用的流程：

socket对象有三块区域
读缓冲区
写缓冲区
等待队列
select函数调用的时候会把当前进程从工作队列里面拿出来
然后把进程引用追加到当前进程关注的每一个socket对象的等待队列中
然后当socket连接的客户端发送完数据之后，数据还是通过硬件DMA的方式把数据写入到内存，然后相应的硬件向CPU发出中断信号,CPU就会让出当前进程位置去执行网络数据就绪的中断程序，
这个中断程序就会把内存中的网络数据写入到对应的socket读缓冲区里面，之后把这个socket等待队列中的进程全部移动到工作队列中，再然后select函数返回
epoll函数流程非常相似

当我们调用系统函数epoll_ ctl时候，比如我们新添加一个需要关注的socket,其实内核程序会把当前的eventpoll对象追加到这个socket的等待队列里头

然后当socket连接的客户端发送完数据之后，数据还是通过硬件DMA的方式把数据写入到内存，然后相应的硬件向CPU发出中断信号,CPU就会让出当前进程位置去执行网络数据就绪的中断程序，

这个中断程序就会把内存中的网络数据写入到对应的socket读缓冲区里面，然后它发现这个socket的等待队列里头不是进程，而是一个eventpoll对象的引用

这个时候呢，他就会根据这个eventpoll对象的引用，将当前socket的引用追加到eventpoll的就绪链表的末尾（eventpoll 还有一块空间是eventpoll 的等待队列，这个等待队列保存的就是调用epoll_wait的进程）

然后，当中断程序把socket的引用追加到就绪列表的末尾之后，就继续检查eventpoll对象的等待队列，如果有进程，就会把进程转移到工作队列中

转移完毕之后，进程就有获取到CPU执行的时间片了，然后就是调用epoll_wait 函数，他这个函数就返回到java层面了

总结：

eventpoll对象等待队列里面，它有调用epoll_wait(,,,)函数进去的进程
然后再把这个进程，从这个eventpoll的等待队列里面迁移到工作队列里面



### 参考链接

http://zhuuu.work/2020/08/17/Linux/Linux-06-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/

https://www.bilibili.com/video/BV12i4y1G7UK?from=search&seid=313526946473138452

http://www.guangjin.fun/?p=244

https://github.com/Mr-jiayunfei/io-multiplexing/blob/main/epoll.cpp



## OSI七层协议

OSI七层协议包括：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层

物联网淑惠试用

## TCP/IP五层协议

TCP/IP五层协议包括：物理层，数据链路层，网络层，运输层，应用层

## 物理层作用

主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。集线器工作在这一层。

集线器的功能：对信号进行再生放大转发，对衰减的信号进行放大，接着转发到其他所有处于工作状态的端口上，以增加信号传输的距离，演唱网络的长度



## 数据链路层有什么作用

在不可靠的物理介质上提供可靠的传输，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。



## 网络层有什么作用

将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。

## 传输层有什么作用

传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

## 会话层有什么作用

建立会话：身份验证，权限鉴定等； 保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局； 断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。

## 表示层有什么作用

对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。



## 应用层有什么作用

提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。

## TCP与UDP区别

TCP作为面向流的协议，提供可靠的、面向连接的运输服务，传送数据之前必须建立连接，数据传送结束后要释放连接。不提供广播或多播服务，比如传输文件

UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅支持点对点，也支持多播和广播，比如音视频

udp的首部只有8个字节，tcp的首部有20字节

## UDP首部

依次是2个字节的源端口号、2个字节的目的端口号、2个字节的数据报长度、2个字节的UDP检验和

![image-20210721183315835](https://i.loli.net/2021/07/21/d6F8JlO3qgQLNPu.png)



## TCP首部

依次是2个字节的源端口号、2个字节的目的端口号

4个字节的序号：在一个TCP连接中传送的字节流中 的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的 序号。

4个字节的确认号：期望收到对方下一个报文段的第一个数据字节的序号,若确认号为N,则证明到序号N-1为止的所有数据都已正确收到。

数据偏移：TCP报文段的 数据起始处距离TCP报文段的起始处有多 远，以4B位单位，即1个数值是4B，即是首部长度

6个控制位：

紧急位URG:URG=1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。
确认位ACK:ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把 ACK置为1。
推送位PSH:PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。
复位RST:RST=1时，表明TCP连接中出现 严重差错，必须释放连接，然后再重新建立传输链接。
同步位SYN:SYN=1时，表明是一个连接请求/连接接受报文。
终止位FIN:FIN=1时，表明此报文段发送方数据已发完，要求释放连接。

2个字节的窗口：指的是发送本报文段的一方的 接收窗口，即现在允许对方发送的数 据量

2个字节的检验和:检验首部+数据

2个字节的紧急指针：URG=1时才有意义，指出 本报文段中紧急数据的字节数

![image-20210721183524717](https://i.loli.net/2021/07/21/MDdBAomzp7tvj31.png)



## 为何TCP可靠

可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。

方法：

1 校验：增加伪首部，使用二进制反码的方式进行校验

2 序号：一个字节占一个序号，TCP首部的序号字段是一个报文段第一个字节的序号

3 确认：确认号为期望收到的下一个序号，如发送方发送一个报文段，里面是1，2，3 ，发送方发送完成之后，不会将这段数据从TCP缓存中移除，万一接收方没有收到，会进行重传。接收方收到数据后，会回复确认帧，确认序号是4，发送方收到接收方发送的确认号为1，知道1，2，3已经被正确确认，可以将1，2，3从缓存中移除。

TCP默认使用累计确认，即发送的确认序号是期望收到的下一个序号，如接收方收到7，8，并没有收到4，5，6，此时发送的确认号依然为4

捎带确认：接收方发送确认号的同时也发送数据

4 重传：TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段（超时重传）

如何设置重传时间？

TCP采用自适应算法，动态改变重传时间RTTs(加权平均往返时间)

冗余确认（快速重传）

每当比期望序号大的失序报文段到达时，发送一个冗余**ACK**，指明下一个期待字节的序号。

发送方收到**3**个对于报文段**1**的冗余**ACK** 认为2报文段丢失，重传2号报文段 快速重传





## 为何UDP不可靠

UDP面向数据报无连接的，数据报发出去，就不保留数据备份了。 仅仅在IP数据报头部加入校验和复用。 UDP没有服务器和客户端的概念。 UDP报文过长的话是交给IP切成小段，如果某段报废报文就废了。

## 简述TCP粘包现象

TCP是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个tcp报文中发出去的可能性。 可以简单的理解成客户端调用了两次send，服务器端一个recv就把信息都读出来了。

## TCP粘包现象处理方法

固定发送信息长度，或在两个信息之间加入分隔符。



## 流量控制 VS 拥塞控制

流量控制是点对点之间的通信产生的问题，是发送方发送数据过快，接收方来不及接收数据产生的问题

拥塞控制是全局性问题，是多个发送方对应一个接收方，网吞吐量随着输入负荷的增加而下降

![image-20210722115613666](https://i.loli.net/2021/07/22/gJqkOfo4CVT3Aj7.png)



## 简述TCP协议的滑动窗口

流量控制：让发送方慢点，要让接收方来得及接收

TCP利用滑动窗口机制实现流量控制。

在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd (接收方设置确认报文段的窗口字段来将rwnd通知给发送方) ，发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最 小值。

Rwnd:接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量

cwnd：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量

滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发 送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。



具体过程：

![image-20210722120439802](https://i.loli.net/2021/07/22/fbLSkxDN2eI8B7r.png)



## 零窗口探测

TCP为每一个连接设有一个持续 计时器，只要TCP连接的一方收 到对方的零窗口通知，就启动 持续计时器。
若持续计时器设置的时间到期， 就发送一个零窗口探测报文段。 接收方收到探测报文段时给出 现在的窗口值。
若窗口仍然是0，那么发送方就 重新设置持续计时器。



## 简述TCP协议的拥塞控制

### 出现拥塞的条件:

对资源需求的总和 > 可用资源（如带宽资源，带宽是50M，多个主机发送数据，带宽资源不够）

网络中有许多资源同时呈现供应不足->>>网络性能变坏--->>>网络吞吐量将随输入负荷增大而下降

### 拥塞控制的目的

防止过多的数据注入到网络中。 是一个全局性问题

### 拥塞控制的方法

慢开始、拥塞避免、快重传、快恢复



慢开始和拥塞避免是结合使用的

慢开始：起始的cwnd为1（拥塞窗口大小为1），所以叫慢开始，慢开始由小到大逐渐增加拥塞窗口的大小，每过一个传输轮次后（收到确认），cwnd乘2（即2，4，8，16等）。

ssthresh: slow start threshhold的缩写, 即慢启动阈值。

当拥塞窗口大小达到慢启动门限后，可以认为发送的数据已经很多了，为了避免网络拥塞，改用拥塞避免算法

拥塞避免：cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。

当网络开始拥塞，拥塞窗口大小达到最大值后（会重新定义ssthresh，即最大值/2），拥塞窗口大小直接由最大值改为1，然后继续执行慢开始算法



![image-20210722133536205](https://i.loli.net/2021/07/22/pP5KlSiMu4NLIJ9.png)



===============================================

当收到三个重复的确认执行快重传算法，

当收到三个重复的确认后，说明网络处于拥塞状态，将ssthresh设置为出现拥塞时发送方窗口值的一半，同时将cwnd设置为ssthresh的值（慢开始和拥塞避免是直接设置为1），之后线性增加cwnd的值（每次增加1）

为什么叫快恢复？

因为发生拥塞的时候不需要把cwnd设置为1，设置为发送方窗口值的一半

![image-20210722134344888](https://i.loli.net/2021/07/22/mVywNUDbOZlhejI.png)

​	

## 简述快重传

如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。



## TCP三次握手过程

1. 第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq=x，并将该数据包发送给服务端，客户端 进入syn_sent状态，等待服务端确认。
2. 第二次握手:服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和 ACK都置为1，ack=x+1,随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。
3. 第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输 数据了



![image-20210721184330909](https://i.loli.net/2021/07/21/71OaVcTfm9ebqAH.png)

## 为什么TCP握手需要三次，两次行不行？

不行。TCP进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值。

如果只是两次握手， 至多只有客户端的起始序列号能被确认， 服务器端的序列号则得不到确认。



## 半连接队列 VS 全连接队列

在TCP三次握手的过程中，Linux内核会维护两个队列，分别是：

半连接队列，也称SYN队列

全连接队列，也称accept队列

服务端收到客户端发起的 SYN 请求后，服务器处于SYN_RECV状态，**内核会把该连接存储到半连接队列**，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，**内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。**

不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。

https://www.cnblogs.com/xiaolincoding/p/12995358.html







![半连接队列与全连接队列](../markdown_note/校招/3.jpg)



## 简述SYN攻击

SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。

优化方式：

1. 缩短SYN Timeout时间
2. 记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。

## TCP四次挥手过程

1. 第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。
2. 第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
3. 第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。
4. 第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。

## 为什么TCP挥手需要4次

主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即close。

所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端。

## 为什么四次挥手释放连接时需要等待2MSL

MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。



# 为何要等待2MSL？

![在这里插入图片描述](../markdown_note/校招/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc4NjIw,size_16,color_FFFFFF,t_70.png)
1.假如第四次挥手失败了，因为丢失而未到达服务器会怎样呢？这样，服务器会一直收不到客户端的回应，也就无法得知客户端是否收到了即将要断开连接的请求。客户端此刻还蒙在鼓里，还在等待服务器继续发送消息。服务器不能判断客户端是否收到，本身就是一个BUG，于是才有的等待2MSL的情况。为了保证客户端最后一次挥手的报文能够到达服务器，若第4次挥手的报文段丢失了，服务器就会超时重传第3次挥手的报文段，所以客户端此时不是直接进入CLOSED，而是保持TIME_WAIT（等待2MSL就是TIME_WAIT）。当客户端再次受到服务器因为超时重传而发送的第3次挥手的请求时，客户端就会重新给服务器发送第4次挥手的报文（保证服务器能够受到客户端的回应报文）。最后，客户端、服务器才真正断开连接。说白了，等待2MSL就是为了确保服务器能够受到客户端最后的回应。
2.如果客户端直接CLOSED，然后又再次向服务器发起一个新连接，谁也不能保证新发起的连接和刚关闭的连接的端口号是不同的，有可能新、老连接的端口号就是一样的。假设新、老连接端口号一致，若老连接的一些数据仍滞留在网络中，这些滞留数据在新连接建立后才到达服务器，鉴于前后端口号一致，TCP协议就默认这些数据属于新连接，于是数据就这样乱成一锅粥了。所以TCP连接还要在TIME_WAIT状态下等待2MSL，确保所有老连接的数据都在网络中消失！

总结来说：
1.为了确保第四次挥手的ACK能被服务器接收到
2.确保所有的老链接都在网络中消失。

# 等待时间为什么是2MSL？

首先说明什么是MSL，MSL是Maximum Segment Lifetime的缩写，译为报文最大生存时间，也就是任何报文在网络上存活的最大时间，一旦超过该时间，报文就会被丢弃。2MSL也就是指的2倍MSL的时间。
为什么是2倍呢？
主动断开的一侧为A，被动断开的一侧为B。
第一个消息：A发FIN
第二个消息：B回复ACK
第三个消息：B发出FIN此时此刻：B单方面认为自己与A达成了共识，即双方都同意关闭连接。此时，B能释放这个TCP连接占用的内存资源吗？不能，B一定要确保A收到自己的ACK、FIN。所以B需要静静地等待A的第四个消息的到来：
第四个消息：A发出ACK，用于确认收到B的FIN
当B接收到此消息，即认为双方达成了同步：双方都知道连接可以释放了，此时B可以安全地释放此TCP连接所占用的内存资源、端口号。
所以被动关闭的B无需任何wait time，直接释放资源。
但，A并不知道B是否接到自己的ACK，A是这么想的：
1）如果B没有收到自己的ACK，会超时重传FiN那么A再次接到重传的FIN，会再次发送ACK
2）如果B收到自己的ACK，也不会再发任何消息，包括ACK
无论是1还是2，A都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：

去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。

这恰恰就是2MSL( Maximum Segment Life)。

等待2MSL时间，A就可以放心地释放TCP占用的资源、端口号，此时可以使用该端口号连接任何服务器。同时也能保证网络中老的链接全部消失。



## 简述DNS协议

DNS协议是基于UDP的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。

## 简述DNS解析过程

1、客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器

2、本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找

3、本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器

4、根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址

5、客户机的dns服务器根据返回的信息接着访问下一级的dns服务器

6、这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息

7、客户机的本地的dns服务器会将查询结果返回给我们的客户机

8、客户机根据得到的ip信息访问目标主机，完成解析过程



## 简述HTTP协议

http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP 是一种无状态的协议。

## 简述cookie

HTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP/1.1 引入 Cookie 来保存状态信息。

Cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。

## 简述session

session用于标记特定客户端信息，存在在服务器的一个文件里。 一般客户端带Cookie对服务器进行访问，可通过cookie中的session id从整个session中查询到服务器记录的关于客户端的信息。



## 简述http状态码和对应的信息

1XX：接收的信息正在处理

2XX：请求正常处理完毕

3XX：重定向

4XX：客户端错误

5XX：服务端错误

常见错误码： 301：永久重定向 302：临时重定向 304：资源没修改，用之前缓存就行 400：客户端请求的报文有错误 403：表示服务器禁止访问资源 404：表示请求的资源在服务器上不存在或未找到

## 转发和重定向的区别

转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。

重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。



## 简述http1.0

浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求，连接无法复用。

## 简述http1.1的改进

HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。

支持管道（pipeline）传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

## 简述HTTP短连接与长连接区别

HTTP中的长连接短连接指HTTP底层TCP的连接。

短连接： 客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束TCP关闭连接。

长连接：如果HTTP头部带有参数keep-alive，即开启长连接网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。



## 简述http2.0的改进

提出多路复用。多路复用前，文件是串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。

引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。



## https作用

1. 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全
2. 对网站服务器进行真实身份认证



## http与https的区别

HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），就是https

1. HTTPS是加密传输协议，HTTP是名文传输协议;
2. HTTPS需要用到SSL证书，而HTTP不用
3. HTTPS标准端口443，HTTP标准端口80



## 简述TLS/SSL, HTTP, HTTPS的关系

SSL全称为Secure Sockets Layer即安全套接层，其继任为TLS Transport Layer Security传输层安全协议，均用于在传输层为数据通讯提供安全支持。

可以将HTTPS协议简单理解为HTTP协议＋TLS/SSL

## http连接过程

1. 浏览器打开一个 TCP 连接
2. 浏览器发送 HTTP 请求到服务器端
3. 服务器发送 HTTP 回应信息到浏览器
4. TCP 连接关闭

## https的连接过程

1. 浏览器将支持的加密算法信息发给服务器
2. 服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器
3. 客户端(SSL/TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。
4. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器
5. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
6. 服务器将加密后的密文发送给客户端
7. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成

## ssh原理

ssh使用rsa非对称加密算法

1. 服务端收到客户端的登录请求，服务端把公钥发送给客户端
2. 客户端用这个公钥，对密码加密
3. 客户端将加密后的密码发送给服务端
4. 服务端用私钥解密，验证OK
5. 返回验证结果

## Get与Post区别

Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。

Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。



## Get方法参数有大小限制吗

一般HTTP协议里并不限制参数大小限制。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使GET请求在浏览器实现层面上看会有长度限制。

## 了解REST API吗

REST API全称为表述性状态转移（Representational State Transfer，REST）即利用HTTP中get、post、put、delete以及其他的HTTP方法构成REST中数据资源的增删改查操作：

- Create ： POST
- Read ： GET
- Update ： PUT/PATCH
- Delete： DELETE

## 浏览器中输入一个网址后，具体发生了什么

1. 进行DNS解析操作，根据DNS解析的结果查到服务器IP地址
2. 通过ip寻址和arp，找到服务器，并利用三次握手建立TCP连接
3. 浏览器生成HTTP报文，发送HTTP请求，等待服务器响应
4. 服务器处理请求，并返回给浏览器
5. 根据HTTP是否开启长连接，进行TCP的挥手过程
6. 浏览器根据收到的静态资源进行页面渲染



## ping原理

ping是基于ICMP协议工作的，主机A给主机B发送ICMP回送请求，主机B收到后，给主机A发送ICMP回送响应，

主机A收到主机B发送的回送响应，则代表主机A到主机B是可达的