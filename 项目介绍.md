# 个人介绍

您好，我叫贾云飞，目前就读于北京航空航天大学软件工程专业，22年1月份左右毕业。本科就读于中央民族大学，所学专业是信息与计算科学，

我之前是在滴滴的自动驾驶部门担任研发实习生，主要工作是改善prediction模块的让行模型，

项目中用到的技术栈主要有C++、Python、ROS、Docker等，

目前在学校参与的实验室项目为成功包络智能预判别项目，是航天五院的一个科研项目，

主要是使用LSTM神经网络预测试验环境下的航天器产品测试数据，

之后使用异常检测、集成学习等方式进行包络识别。

编程语言方面，我对C++比较熟悉，Python、Java、C#、SQL等在项目开发中都使用过，以上就是我的个人介绍，谢谢！







# 滴滴实习项目介绍



我在滴滴参与的主要项目是使用人工驾驶数据集改善prediction模块让行模型的预测效果。

我先大概介绍一下voyager自动驾驶项目的整体模块设计，voyager项目主要由4个模块组成，HDMAP，也就是高精地图，Percetion感知模块，Prediction预测模块，Planing and Control规划和控制模块，高精地图主要提供高精度的地图数据，人类开车需要普通的导航地图就可以，精度可能在2-3米，高精地图提供车道线级别的地图数据，精度在厘米级别，Perception模块主要是感知周围的物体，如交通灯、行人、vehicle等，并对他们进行标注，Prediction主要是预测交通参与者如行人、自行车、三轮车、普通车辆在未来一段时间的运动轨迹，Planning and  control模块主要是根据prediction模块的结果规划自车的运动轨迹并控制车辆进行前进，模块与模块之间进行数据交互主要是使用ROS系统，ROS就是Robot operate System机器人操作系统。



然后我大概介绍一下prediction模块的大致处理流程，prediction模块主要接收HDmap和perception信息，HDmap模块主要提供车道信息、perception模块主要提供object信息，即观察到的交通参与者信息，首先，第一步，prediction模块利用这些信息进行环境建模 ，保存当前场景。第二步预测交通参与者的intention，即意图预测，如是否进行换道、是否进行左转或者右转等。第三步进行交通参与者的让行intention预测，主要预测交通参与者是否会让行自车，第四步根据交通参与者的intention生成referenceline，即参考车道，第五步根据referenceline生成交通参与者未来一段时间的运动轨迹，如车辆预测未来11s的轨迹，普通行人预测未来6s的轨迹，最后将交通参与者的运动轨迹进行打分，并将得分最高的两条轨迹发送给下游的planning模块，得分最高的两条轨迹也就是可能性最大的两条轨迹，planning模块根据这些信息进而规划自车的运动。



我参与的主要是prediction模块的一个yield model，即让行模型的改善。目前存在的问题是在自车处于低路权，agent处于高路权的场景下，模型预测结果偏向让行，和预期结果不一致，期望结果是agent处于高路权、ego处于低路权，模型预测结果不应该偏向让行，导致这个问题的主要原因是使用的是自动驾驶的数据集，自动驾驶的行为偏向保守，这个结果直接导致的就是急刹多，影响驾驶体验，需要人类驾驶员接管等，所以需要改善。改善方法是在人工驾驶的模式下，收集相关数据，人类驾驶的行为会比自动驾驶更为激进，在驾驶过程中，不会有那么多的让行样本，期望模型预测结果与人类结果更为一致。



首先就是分析自动驾驶的数据集和人类驾驶的数据集的样本特征分布差异，针对模型的每一个特征，观察自动驾驶数据和人工驾驶数据的分布区别，找出不合理的特征或者需要完善的特征，主要使用的是直方图的形式。就比如说计算ego和agent到达冲突点的时间特征时，计算时间需要距离、速度、加速度等特征（s = vt+at*t/2）,在分析中发现在自动驾驶的样本中，有26%的ego 速度是0，在人工驾驶数据集中有，有9%的样本ego速度是0，这个分布是符合预期的，因为自动驾驶的行为偏向保守，但是之前的ego vehicle这个特征，只有agent vehicle这个特征，所以增加自车速度这个特征，更好的描述当前场景。同时在使用加速度的时候，发现只考虑了减速一种情况。但实际情况时，在到达冲突点的过程中，加速、减速、匀速都有可能，所以将到达冲突点的时间这个特征扩展为3维特征，同时有diff特征，也就是自车和agent到达冲突点的时间差，这个特征也相应的扩展维9维特征。

又比如说conflict_turn_type这个特征，这个特征主要描述的是冲突类型，第一个维度是agent lane type，比如说直行或者右转等，第二个维度是冲突类型，有两个值，一个是crossing，一个是merging，意思是agent和ego的lane可以crossing或者merging。但思考之后，发现这两个维度不足以描述所有情况，比如agent左转，冲突类型是crossing，但ego可能是直行，对向车道直行或者左转等情况，这两个特征不足以描述所有情况，所以又增加了一个维度，也就是自车的车道类型，用来反应自车的情况。 同时在分析这个特征的过程中发现，agent直行、ego crossing这个场景在人工驾驶数据集中占据46%，而在自动驾驶数据集中占据27%,样本分布不平衡也可能对模型的性能有所影响，后续可能会对样本进行平衡操作。



又比如说路权特征，之前的路权特征只是ego和agent的路权分数之差，不能很充分的描述，因为ego或者agent可能在不同的车道，所以之后又增加了ego_right_of_way和agent_right_of_way两个特征。



完善特征后重新进行模型训练，测试主要将数据集拆分为训练集和测试集，有自动驾驶数据和人工驾驶数据，

相应的训练集有三个人工驾驶数据、自动驾驶数据、混合数据

测试集有人工驾驶数据、自动驾驶数据

每种都进行训练后得出混合数据训练出来的模型最好（94%左右，混合比例是1：10）



使用该模型进行路测，得出的结果是比之前的模型行为更为激进一点。



遇到的问题：

分析代码发现yield模型的groudtruth 的计算逻辑只是简单的比较了 agent 和 ego 到达冲突点的时间，如果 ego 先过，就说是让行了，反之就是没有让行，而且是前面10 帧的数据都会用最后这个 groudtruth，但如果行驶过程中，有博弈过 程，比如 agent 减速让 ego，但是 ego 是起步比较慢，最后 agent 先过了，最后的标注结果是没有让行，目前的label和feature没有体现这种动态的博弈过程，需要持续进行改善。而且这种情况目前没有比较好的办法解决，只能是找到两种模型预测结果不一致的场景进行复现，然后人眼进行观察，看这个过程中是否有博弈的情况，然后分析比较两个模型的特征值差异，期望找到一些特征可以解释这种情况，目前没有什么进展。





```
哪个效果最好？（混合效果最好）

最终目标是使用人工驾驶数据训练出来的模型表现在自动驾驶的测试集上表现效果比较好，为什么要加另外几种？

测试集应该只用human集，本质上我们想让模型的结果和robot的结果不一致，如果使用robot作为测试集的话，是期望行为和robot一致，理想情况下应该只用human测试集，但是只所以使用robot测试集，是因为和master做比较，master是基于robot训练集和robot测试集
```



分析比较LightGBM和NeuralNetwork在让行模型上的表现优劣：

主要是为了测试深度模型是否比树模型效果更好

训练过程和之前的树模型相同，有不同的训练集和测试集，分别对其进行测试，发现在每种数据集上都比树模型的效果略有改善（95%左右）。

之后就是修改onboard代码，准备路测

模型分为onborad和offboard，其实也就是在线和离线（在车上运行和不在车上运行），离线的代码时python写的，需要使用python代码训练模型。

在线代码使用C++开发，C++速度更快，需要使用C++加载python训练好的模型，从github上找了一个MLP的开源代码，将其进行适配，主要内容就是python训练好模型后，将模型的参数保存成文本文件，神经网络本身是矩阵的乘法，C++加载解析这个文件，然后使用这个参数进行模型预测。网络比较简单，使用的就是两个全连接层，文件保存的参数有每一层的结点个数，每个节点的输入数量，每个节点的输入权重，比如有50个特征，第一层就是有50个节点，第二层有256个节点，第三层有256个节点，第四层有一点节点，第二层的256个节点每个节点都会和前一层的50个节点相连，每个连线都会有一个权重，就是把这些信息保存下来。MLP的模型还没有进行路测，之后应该也要进行路测。



调研airflow工具实现自动化的data pineline：

从采集数据到训练模型主要经过几个步骤：

1 路测的时候，会将雷达、激光雷达、camera收集到的信息存成rosbag包，rosbag包会存储到文件服务器中（20s的数据大概一个G，数据量比较大）
2 挑选一些我们想要的数据，利用这些数据生成样本（挑选关键帧，数据比较多，我们只想要自车低路权的数据，我们会将关键帧的前后20s的数据都找出来）
4 对数据进行标注（autolabel）
5 下载样本
6 对模型进行训练
7 对模型进行测试，
整个过程都需要人工进行的话，比较麻烦，所以考虑实现一个自动化的pipeline，
每次更新数据或者更新代码的时候，直接激发任务，就会自动把整个流程执行为，过程中不需要人为进行干涉









# 创奇视界项目介绍



工作描述：

1 负责基于DDS的分布式仿真平台项目的开发和测试，主要使用Qt完成用户层的界面开发，使用OpenSplice框架完成分布式系统的节点通信，使用C++完成引擎控制层及仿真引擎层的相关功能开发；

2 负责基于DDS的分布式仿真平台项目的Linux移植工作；

3 负责云仿真项目的引擎适配，使用docker进行容器化测试部署；

4 负责综合控制软件的架构设计、开发和测试‘’



工作描述：



1 负责基于DDS的分布式仿真平台项目的开发和测试，项目成功在XX院所完成部署。



2 负责基于DDS的分布式仿真平台项目的Linux移植打包工作，项目成功在中标麒麟系统上部署运行；



3 负责云仿真项目的引擎适配，使用docker进行容器化测试部署，项目成功在XX院所完成第一阶段验收；



4 负责综合控制软件的架构设计、开发和测试，项目成功在XX院所完成验收







我在职期间参与周期最常的项目是基于DDS的分布式仿真平台项目，我首先介绍一下项目背景，为什么要有这个软件，这个软件要完成什么功能？比如说红方和蓝方近期可能要作战，我们直接在现实世界中进行模拟作战场景，是非常消耗资源的，但是如果我们通过仿真软件，进行一系列的仿真试验，并对仿真结果加以分析，选取最好的作战方案，就能节约很多资源，并且提高作战胜率，基于此需求，我们就需要开发出一款仿真软件，对各种仿真场景加以模拟。接下来，我简单介绍一下一个完整的仿真试验的基本流程：

1 首先是模型管理，就是构建各种模型，如卫星、雷达、舰船，根据他们的真实特性编写完成相关代码和辅助文件

2 第二部分是想定编辑，它的主要目的是生成一个完整的想定文件，这个文件保存的实体的属性信息，比如实体的经纬度，同时也保存着模型之间数据收发关系。

3 第三部分是态势显示，主要用来显示仿真运行过程中的实体状态变化，包括用gis完成的二维态势页面和用unity完成的三维态势页面

4 第四部分是仿真运行模块，主要用来控制仿真推演的开始、暂停、继续、结束、仿真步长、仿真倍速等

5 第五部分是引擎管理模块，主要包络时间管理、结点管理、主题管理、实体管理、opensplice中间件封装等

6 第六部分是数据管理部分，主要用来管理仿真过程中产生的数据，主要包括使用mongdb存储仿真数据，使用spdlog管理仿真日志

7 第七部分是数据回放部分，主要是根据monggodb存储的数据进行仿真试验的回访

8 第八部分是分析评估，主要用来分析本次试验结果是否正常，有何改进的地方

这些就是一个完整的仿真试验流程，我主要完成想定编辑模块、仿真运行模块、引擎管理模块，其他模块完成一些小功能的开发





项目难点

1 为模型设计统一的输入输出计算接口

  模型是其他单位做，我们单位也在做，然后在我们的仿真平台上运行，如果接口不一致，那就跑不起来，所以接口必须通用

  其次是模型也有组合模型一说，比如轰炸机模型就有飞机、雷达、导弹这些模型组合起来成为一个大模型，组合模型下需要和其他模型进行数据交互，组成组合模型的小模型之间也需要进行数据交互

模型也可能动态创建，比如导弹发射车在规定的时间发射导弹，导弹是动态创建出来的，诸如此类，

如何为模型设计一套统一的接口前期也花了很多时间

Setvalue函数、Getvalue函数、Tick函数、Init函数、InitValue函数

发布订阅者模式，Setvalue即是订阅主题数据，比如A模型订阅了3个主题的数据，每个主题有5个参数，需要给模型传15个参数

Setvalue即是给模型赋值，Getvalue即是发布主题数据，有一些问题，是把他的参数全部抛出去呢，还是等待其他模块调用，需要那个主题的数据，传那个主题的数据等等这些问题。。。

设计了一个模型基类，实现了这些接口，开发新的模型只需要继承基类模型即可。



2 仿真任务之间如何切换？

比如一个仿真步长要执行完APhase,BPhase,CPhase三个仿真任务，每个仿真任务需要完成不同的事情。每个任务之间如何进行切换？执行完三个仿真任务后，需要执行下一个仿真步长，整个过程如何管理起来更方便？



引入了一个时间管理模块和线程池模块，时间管理会往外发送仿真步长帧和任务帧，如任务帧是1，将APhase仿真任务压进线程池的工作队列当中，执行APhase仿真任务，执行完仿真任务后，回到时间管理模块，任务帧+1，将BPhase仿真任务压进线程池的工作队列当中，执行BPhase仿真任务，执行完仿真任务后，回到时间管理模块，依次循环，进行任务切换与仿真推进。



在时间管理模块也完成实时模式与超实时模式设置，仿真倍速与仿真模式设置等功能



3 如何更高效的执行仿真任务？

比如有10个实体，都要执行APhase仿真任务，如果我们串行的对这个10个实体执行，一方面仿真速度比较慢，一方面不能充分利用计算机的资源，所以使用多线程技术，引入了taskflow开源库，当有10个实体都要执行APhase仿真任务，开启10个线程并行的执行仿真任务，提高效率，因为线程之间不进行同步，所以之前的单线程也可以完成任务，只是效率比较慢



3 数据显示模块的更新问题？

 绘图一般比较费时间，如果界面绘制一帧取一帧数据，会导致DDS中的数据比较进行紧张，影响数据收发效率，

加了一个缓冲队列，引入了开源库ConcurrentQueue，显示界面直接从队列中取数据，而模型发布的数据也都先存在缓冲队列中，

而且显示模块有二维的gis模块、云平台的浏览器页面，三维开发的unity界面，所以需要统一发送的数据格式，最终确定为按时间帧排列的json数据串



5 仿真平台界面和仿真运行管理模块的同步，分布式系统中，主控节点的界面点击开始后，其他节点的界面也要同步开始，同步显示仿真状态。

仿真平台界面客户要求扁平化，实现word的那种效果，查阅相关资料，完成该功能。

日志查看界面，客户嫌弃使用记事本打开日志文件比较慢，需要我们做一个，而且要有查找过滤功能，使用了mvc模式，完成了界面，核心思想就是边读文件边显示，而且用户向下拉滚动条的时候才会更新，查找过滤是使用的代理模式，如果符合要求，代理会帮视图自动处理。





想定编辑模块是使用QT完成的界面，主要包括模型部署、阵营管理、实体管理、主题创建与编辑、模型发布订阅管理、想定文件生成与加载管理

仿真运行模块主要主要用来控制仿真推演的开始、暂停、继续、结束，同时允许以实时模式和超实时模式进行仿真推演

引擎管理层主要包括时间管理模块、节点管理模块、主题管理模块、实体管理模块等，时间管理模块主要用来管理主控节点和受控节点的时间同步问题，节点管理模块主要用来控制想定分发问题，主题管理模块主要用来管理数据的发布订阅，实体管理模块主要用来管理实体的创建销毁等。



1 使用Qt完成想定编辑模块的开发，便于用户使用界面生成完整的想定文件



2 使用OpenSplice消息中间件完成分布式系统中主控节点和受控节点的时间同步功能



3 完成仿真运行过程中以实时模式和超实时模式进行仿真推演功能



4 完成分布式系统节点之间同步开始、暂停、继续、结束仿真试验等功能



4 封装spdlog开源库完成系统日志功能



5 完成想定实体之间的聚合解聚功能，完成编队模型相关功能



6 完成该项目Linux系统移植打包工作，成功在中标麒麟系统上部署运行



7 使用Docker对引擎管理模块进行容器化测试部署