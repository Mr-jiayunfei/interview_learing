# 8月18日新浪笔试

## 青蛙跳台阶

https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/

## [删除一个字符串中所有出现的给定子字符串](https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/)



## [ 网格中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)



## [ 最大的团队表现值](https://leetcode-cn.com/problems/maximum-performance-of-a-team/)



链接：https://www.nowcoder.com/discuss/711776?type=all&order=time&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack
来源：牛客网

简历上的项目
STL容器的sort底层是采用的什么排序？
排序算法的稳定与不稳定如何判别
排序不稳定的根源
C++多态的实现方式
内联函数可以为虚函数吗？
手写一个函数指针 
手撕代码： [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)



# 为什么要有初始化表？

# 基类的析构函数为什么要设计为虚函数？

# 智能指针有几种？

# 每种智能指针的实现原理？

# 虚函数的实现原理（多态）

# 构造函数为什么不能声明为虚函数

# 为什么要虚析构,为什么不能虚构造

# 构造函数有几种



# =================



# 说一下操作系统内存管理

# 进程线程区别

# 进程线程通信同步,说一下各自用途

# 一个线程占多大内存



# ==================





# TCP三次握手四次挥手

# TCP/UDP区别,能说一下,包头都有什么吗?

tcp可靠性保证?

说一下滑动窗口

确认机制

重传机制

2次握手行不行?为什么要3次

为什么要2倍timewait

tcp半连接队列

SYNflood以及解决方法



# 数据库



说一下数据引擎

mysql 几种索引,事务

mysql 事务隔离级别,

索引优化,查询优化

索引失效

索引为什么用B+树,不用avl/ RB树

说一下RB树和AVL区别

聚簇索引/非聚簇,innodb和myisam用的哪个?好处?  



作者：牛客网
链接：https://zhuanlan.zhihu.com/p/265789363
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



**代码:**

单例模式

懒汉饿汉线程安全

代码题:

给一段序列,a[i] 为当前人的身高, 能向左看右看比他高的人 和 第一个比他矮的(递减序列看不到), 问每个人都能最大看到的人数是几个?

解决思路:单调栈遍历,向左能看多少人写一个单调递减栈,向右能看多少人,倒序遍历,单调递减栈.

**二面1h10min**

常规扯蛋,喜不喜欢lol,和平精英哪里做的不好?哪里玩的比较爽,想加入什么元素?

说一下new 4G的过程,会不会实际分配,32G电脑new 128G呢,

malloc实现原理?

32位电脑内核空间和用户空间?64位呢?

迭代器失效问题,如何解决,it++ 和 ++it区别?(++it传引用,it++传值复制)

stl 的map hashtable deque list 请说一下,每个实现原理说一下

hashtable扩容和如何解决冲突,解决冲突的办法

vector 装入第8个元素会怎么样(扩容机制)

push_back和emplace_back

如何使用c来实现重载和重写(重点虚函数的实现机制)

左值右值

右值引用,移动语义完美转发

const有几种使用方法

为什么使用const修饰....

深拷贝浅拷贝

空类大小,为什么是1,默认实现了什么?

纯虚函数能实例化吗,为什么?派生类要实现吗,为什么

有几种传值..说一下引用和指针,为什么引用...指针...

向上转型/向下转型

内存泄漏,野指针

智能指针分别说一下

sharedptr,weakptr,uniqueptr,autoptr

shreadptr计数,线程安全性,解决

类型转换

mvcc的实现原理

知道几种锁,说一下

说一下乐观锁,悲观锁,行锁,表锁

场景题:

100w个玩家一起创建角色...中途如果有玩家取消创建...

1亿数据排序

代码题:

区间贪心,给几个时间段的活动,要求出最多能同时做几个活动?

HR面.....没记录,蛮好的

全程没问项目.....快问快答,面试官会提示点,引导回答,面试官看不了解了,会马上问下一个问题.

与作者交流：[双非本科上岸腾讯IEG光子后台面经(已意向)_笔经面经_牛客网](https://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/539058%3Ffrom%3Dzhnkw)

更多笔经面经：[笔经面经_互联网求职学习交流_讨论区_牛客网](https://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/experience/index%3Ffrom%3Dzhnkw)



# 真题

## 墨奇科技

### 长度最小的子数组

https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 

## 滴滴

树的中序遍历

消费者生产者问题



## 诺瓦科技

Http1、http1.0 、http2.0区别

ssh原理

ping原理

字符串中找到第一个出现一次的字符

多生产者多消费者

两个有序链表合并为一个有序链表

String完成构造函数、拷贝构造函数、拷贝赋值函数、析构函数

进程有几种状态？

中断的原理

半连接队列、全连接队列

互斥锁和读写锁的区别

静态编译和动态编译的区别



## 阿里

TCP三次握手四次握手

TCP/UDP区别,能说一下,包头都有什么吗?

tcp可靠性保证?

说一下滑动窗口

确认机制

重传机制

2次握手行不行?为什么要3次

为什么要2倍timewait

tcp半连接队列

SYNflood以及解决方法

## 腾讯面试

1 new 和malloc的区别
2 tcp粘包现象？为什么会产生这种现象，怎么解决？
3 tcp的四次挥手过程
4 最后一次挥手，服务器为什么要等待2SSL（2个原因）

客户端的最后一次ack没有被服务端收到的话，那么服务端会进行重传第三次的释放连接请求，TIME_WAIT就是为了在这种情况下重发丢失了的ack报文。

5 什么是虚拟内存？虚拟内存解决了什么问题？
6 什么是缺页中段？

7 C++构造函数为什么要用初始化表，在初始化表主要干嘛？（const类型的变量）
8 析构函数为什么设置为虚函数？
8 什么是动态？多态是如何实现？
9 多态分为动态多态和 静态多态？

10 什么是IO多路复用？
11 虚函数表是什么时候建立？怎么查找？

12 什么是棱形继承？棱形继承有什么问题？怎么解决？

13 为什么虚继承可以解决棱形继承？如何解决的？

14 什么是智能指针？智能指针有哪些？

15 为什么要引入weak_ptr，解决什么问题？

16 进程间通信方式？线程间通信方式？

17 共享内存为什么效率最高？和其他方式相比高在哪里？

18 进程切换和线程切换有什么区别？消耗的资源少在哪里？

19 为什么选择MongDB？MongDB和其他数据库的区别？和其他非关系型的数据库

20 kafka的实现原理？如何实现？

动态规划 吃掉 N 个橘子的最少天数

## 蓝湖笔试

1 回溯法

象棋从起点走到终点

1 只能走日字

2 只能向右上方走

输出返回从起点到终点的解法



2 贪心法

分发糖果



# 美团

## 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？

## 为什么TCP连接的时候是3次？2次不可以吗？

## 为什么TCP连接的时候是3次，关闭的时候却是4次？

## TCP 怎么保证可靠传输？



# 腾讯笔试

```c++
/**

 * struct ListNode {
 * int val;
 * struct ListNode *next;
 * ListNode(int x) : val(x), next(nullptr) {}
 * };
   */
   /**
 * struct TreeNode {
 * int val;
 * struct TreeNode *left;
 * struct TreeNode *right;
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
   */

class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 你需要返回m个指针，第i个指针指向一条链，表示第i个问题的答案
     * @param root TreeNode类 指向链表树的根
     * @param b int整型vector 表示每个问题是什么
     * @return ListNode类vector
     */
    vector<ListNode*> solve(TreeNode* root, vector<int>& b) {
        // write code here
        vector<int> tmp[1002];
        vector<int> u;
        function<void(TreeNode*)> dfs = [&](TreeNode* cur) {
            u.push_back(cur->val);
            tmp[cur->val] = u;
            if (cur->left) dfs(cur->left), u.pop_back();
            if (cur->right) dfs(cur->right), u.pop_back();
        };
        dfs(root);
        vector<ListNode*> ret;
        for (int i = 0; i < (int)b.size(); i++) {
            ListNode* head = new ListNode(-1);
            ListNode* f = head;
            for (int u : tmp[b[i]]) {
                head->next = new ListNode(u);
                head = head->next;
            }
            ret.push_back(f->next);
        }
        return ret;
    }

};
---------------------------------------------------------------------------------------------

#include <bits/stdc++.h>

using namespace std;

int main() {
    int tt;
    scanf("%d", &tt);
    while (tt--) {
        int nn;
        scanf("%d", &nn);
        unordered_map<int,int> dp;
        queue<int> que;
        dp[nn] = 0;
        que.push(nn);
        while(!que.empty()) {
            int n = que.front(); que.pop();
            //cout << "tmp == " << n << endl;
            if (n == 0) {
                cout << dp[n] << "\n";
                break;
            }
            if (dp.count(n - 1) == 0) {
                dp[n - 1] = dp[n] + 1;
                que.push(n - 1);
            }
            if (n % 2 == 0 && dp.count(n / 2) == 0) {
                dp[n / 2] = dp[n] + 1;
                que.push(n / 2);
            }
            if (n % 3 == 0 && dp.count(n / 3) == 0) {
                dp[n / 3] = dp[n] + 1;
                que.push(n / 3);
            }
        }
    }
    return 0;

}
----------------------------------------------------------------------------------------------

#include <bits/stdc++.h>

using namespace std; 

int b[10020];
int pos[10020];

int main()
{
    int n;
    scanf("%d", &n);
    vector<vector<int>> a(n);
    for (int i = 0; i < n; i++) {
        int m;
        scanf("%d", &m);
        a[i].resize(m);
        for (int j = 0; j < m; j++) {
            scanf("%d", &a[i][j]);
        }
        sort(a[i].begin(), a[i].end());
    }
    int q;
    scanf("%d", &q);
    while (q--) {
        int p, k;
        scanf("%d", &p);
        for (int i = 0; i < p; i++) {
            scanf("%d", &b[i]);
        }
        scanf("%d", &k);
        int index, Min;
        memset(pos, 0, sizeof(pos));
        while (k--) {
            index = -1;
            Min = INT_MAX;
            for (int i = 0; i < p; i++) {
                int x = b[i] - 1;
                int y = pos[b[i] - 1];
                if (y >= (int)a[x].size()) continue;
                if (a[x][y] < Min) {
                    Min = a[x][y];
                    index = i;
                }
            }
            if (index == -1) {
                break;
            }
            pos[b[index] - 1]++;
        }
        cout << Min << "\n";
        

    }
    return 0;

}
------------------------------------------------------------------------------------



#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = (int)1e5 + 10;

struct Node {
    int x, y;
}a[N];

signed main() {
    int n, w;
    scanf("%lld %lld", &n, &w);
    for (int i = 0; i < n; i++) {
        scanf("%lld %lld", &a[i].x, &a[i].y);
    }
    sort(a, a + n, [&](const Node& foo, const Node& bar){return foo.y < bar.y;});
    cout << a[n / 2].y << endl;
    return 0;

}
----------------------------------------------------------------------------------------------------

#include <bits/stdc++.h>
#define int long long
using namespace std;
int w[10010];
signed main()
{
    int tt;
    cin >> tt;
    while (tt--) {
        int n, m;
        int ans = 0;
        scanf("%lld %lld", &n, &m);
        vector<vector<int>> vec(m);
        for (int i = 0; i < n; i++) {
            scanf("%lld", &w[i]);
            vec[w[i] % m].push_back(w[i]);
            ans += w[i];
        }
        for (int i = 0; i < m; i++) {
            sort(vec[i].begin(), vec[i].end(), [&](int x, int y){return x > y;});
        }
        int sum = 0;
        for (int i = 0; i < (int)vec[0].size(); i++) sum += vec[0][i];
        if (m % 2 == 0) {
            if (vec[m / 2].size() % 2 == 0) {
                for (int i = 0; i < vec[m / 2].size(); i++) sum += vec[m / 2][i];
            } else {
                for (int i = 0; i < vec[m / 2].size(); i++) sum += vec[m / 2][i];
                sum -= vec[m / 2].back();
            }
        }
        for (int i = 1; i < (m + 1) / 2; i++) {
            int foo = i;
            int bar = m - i;
            int l = 0, r = 0;
            while (l < (int)vec[foo].size() && r < (int)vec[bar].size()) {
                sum += vec[foo][l];
                sum += vec[bar][r];
                l++;
                r++;
            }
        }
        cout << ans - sum << endl;
    }
    return 0;
}
```





## 1 为什么要有初始化表？

## 2 基类的析构函数为什么要设计为虚函数？

## 3  智能指针有几种（shared_ptr,unique_ptr,weakPtr,autoptr）？每种智能指针的实现原理？

## 4 虚函数的实现原理（多态）

## 5 构造函数为什么不能声明为虚函数（为什么要虚析构,为什么不能虚构造）

## 6 构造函数有几种



给定一个字符串，你的任务是计算这个字符串中有多少个回文子串（回文串是一个正读和反读都一样的字符串）。

具有不同开始位置或结束位置的回文串，即使是由相同的字符组成，也会被计为是不同的子串。





有 N 堆金币排成一排，第 i 堆中有 C[i] 块金币。每次合并都会将相邻的两堆金币合并为一堆，成本为这两堆金币块数之和。经过N-1次合并，最终将所有金币合并为一堆。请找出将金币合并为一堆的最低成本。

其中，1 <= N <= 30，1 <= C[i] <= 100、



给定一组个字符串，为每个字符串找出能够唯一识别该字符串的最小前缀。





说一下操作系统内存管理

进程线程区别

进程线程通信同步,说一下各自用途

一个线程占多大内存,



说一下数据引擎

mysql 几种索引,事务

mysql 事务隔离级别,

索引优化,查询优化

索引失效

索引为什么用B+树,不用avl/ RB树

说一下RB树和AVL区别

聚簇索引/非聚簇,innodb和myisam用的哪个?好处?  



**代码:**

单例模式

懒汉饿汉线程安全

代码题:

给一段序列,a[i] 为当前人的身高, 能向左看右看比他高的人 和 第一个比他矮的(递减序列看不到), 问每个人都能最大看到的人数是几个?

解决思路:单调栈遍历,向左能看多少人写一个单调递减栈,向右能看多少人,倒序遍历,单调递减栈.

**二面1h10min**

常规扯蛋,喜不喜欢lol,和平精英哪里做的不好?哪里玩的比较爽,想加入什么元素?

说一下new 4G的过程,会不会实际分配,32G电脑new 128G呢,

malloc实现原理?

32位电脑内核空间和用户空间?64位呢?

迭代器失效问题,如何解决,it++ 和 ++it区别?(++it传引用,it++传值复制)

stl 的map hashtable deque list 请说一下,每个实现原理说一下

hashtable扩容和如何解决冲突,解决冲突的办法

vector 装入第8个元素会怎么样(扩容机制)

push_back和emplace_back

如何使用c来实现重载和重写(重点虚函数的实现机制)

左值右值

右值引用,移动语义完美转发

const有几种使用方法

为什么使用const修饰....

深拷贝浅拷贝

空类大小,为什么是1,默认实现了什么?

纯虚函数能实例化吗,为什么?派生类要实现吗,为什么

有几种传值..说一下引用和指针,为什么引用...指针...

向上转型/向下转型

内存泄漏,野指针

智能指针分别说一下

sharedptr,weakptr,uniqueptr,autoptr

shreadptr计数,线程安全性,解决

类型转换

mvcc的实现原理

知道几种锁,说一下

说一下乐观锁,悲观锁,行锁,表锁

场景题:

100w个玩家一起创建角色...中途如果有玩家取消创建...

1亿数据排序

代码题:

区间贪心,给几个时间段的活动,要求出最多能同时做几个活动?

HR面.....没记录,蛮好的

全程没问项目.....快问快答,面试官会提示点,引导回答,面试官看不了解了,会马上问下一个问题.

与作者交流：[双非本科上岸腾讯IEG光子后台面经(已意向)_笔经面经_牛客网](https://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/539058%3Ffrom%3Dzhnkw)

更多笔经面经：[笔经面经_互联网求职学习交流_讨论区_牛客网](https://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/experience/index%3Ffrom%3Dzhnkw)















2 











4 请简要描述MySQL数据库联合索引的命中规则，可举例说明。

什么是分布式事务，分布式事务产生的原因是什么？分布式事务的解决方案有哪些？分别有哪些优缺点？



分布式事物：将一次大的操作分为很多小的操作，这些小的操作位于各自的服务器上，分布式事物需要保证这些小的操作要么全部成功，要么全部失败。

分布式事物产生的原因：1.为了解决不同数据库操作时数据不一致的问题。2.应用SOA话。

分布式事物的解决方案：

1.2PC：两阶段提交

优点：保证数据的强一致性，适合对数据要求高的强一致性领域。

缺点：实现复杂，牺牲了可用性，性能不高，不适合高并发，高性能的场景。

2.3PC:三阶段提交

优点：相对于二阶段，它减低了阻塞的范围，解决了协调者这参与者同时挂掉的问题，即等待超时后，协调者或参与者会中断事务，避免单点问题。

缺点：数据不一致性依然存在。

3.补偿事务（TCC）

优点：1）性能提升，2）数据最终一致， 3）可靠性更高

缺点：花费高

请描述https的请求过程。

1) 客户端向服务器发起HTTPS请求，连接到服务器的443端口；

2) 服务器端有一个密钥对，即公钥（即数字证书）和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人；

3) 服务器将自己的公钥发送给客户端；

4) 客户端收到服务器端的公钥之后，检查其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续，如果公钥合格，则客户端会生成一个客户端密钥，然后用服务器的公钥对客户端密钥进行非对称加密成密文，至此，HTTPS中的第一次HTTP请求结束；

5) 客户端发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器；

6) 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文；

7) 然后服务器将加密后的密文发送给客户端；

8) 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。



# b[i]+b[j]+b[k] 的最小值

```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>

using namespace std;

//i<j<k  a[i]<a[j]<a[k] 
//b[i]+b[j]+b[k]

//暴力解法
int Test(vector<int> va, vector<int> vb)
{
	int res = INT_MAX;
	for (size_t i=0;i< va.size();++i)
	{
		for (size_t j = i+1; j < va.size(); ++j)
		{
			for (size_t k = j + 1; k < va.size(); ++k)
			{
				if (va[k]>=va[j] && va[j]>=va[i])
				{
					int sum = vb[i] + vb[j] + vb[k];
					if (sum < res)
					{
						res = sum;
					}
				}
				else
				{
					continue;
				}
			}
		}
	}
	return res;
}

int main()
{
	int n, ans = 0;
	cin >> n;
	vector<int> va, vb;
	for (int j = 0; j < n; j++)
	{
		int x;
		scanf_s("%d", &x);
		va.push_back(x);
	}
	for (int j = 0; j < n; j++)
	{
		int x;
		scanf_s("%d", &x);
		vb.push_back(x);
	}

	int res = Test(va, vb);
	std::cout << res << std::endl;
	return 0;

}
```



# 实现一个简单的计算器

```C++
#include <unordered_map>

class Solution {
public:
	unordered_map<char, int> oper_pri = {
			{'+',1},
			{'-',1},
			{'*',2},
			{'/',2},
			{'%',2},
			{'^',3}
	};
	stack<char> opers;
	stack<long long> nums;
	int calculate(string s) {
		nums.push(0);
		int n = s.size();
		for (int i = 0; i < n; i++) {
			if (s[i] == ' ') continue;
			else if (s[i] == '(') {
				opers.push('(');
				if (s[i + 1] == '-') {
					i++;
					nums.push(0);
					opers.push('-');
				}
			}
			else if (s[i] == ')') {
				while (opers.top() != '(') {
					cal();
				}
				opers.pop();
			}
			else if ('0' <= s[i] && s[i] <= '9') {
				int l = i;
				while (i + 1 < n && '0' <= s[i + 1] && s[i + 1] <= '9')
					i++;
				nums.push(stoll(s.substr(l, i - l + 1)));
			}
			else {
				if (i>=1 && s[i - 1] == '(')
				{
					nums.push(0);
				}
				while (!opers.empty() && opers.top() != '(' && oper_pri[opers.top()] >= oper_pri[s[i]]) {
					cal();
				}
				opers.push(s[i]);
			}
		}
		while (!opers.empty() && opers.top() != '(') {
			cal();
		}
		return nums.top();
	}
	void cal() {
		long long b = nums.top(); nums.pop();
		long long a = nums.top(); nums.pop();
		char oper = opers.top(); opers.pop();
		long long res;
		switch (oper) {
		case '+':   res = a + b; break;
		case '-':   res = a - b; break;
		case '*':   res = a * b; break;
		case '/':   res = a / b; break;
		case '%':   res = a % b; break;
		case '^':   res = pow(a, b); break;
		}
		nums.push(res);
	}
};



int main()
{
	Solution Solution;
	string s = "-2+ 1";
	int res = Solution.calculate(s);
	cout << res << std::endl;
    std::cout << "Hello World!\n";
}
```



## 美团二面

1 手写快速排序

2 tcp三次握手，四次挥手

3 osi七层模型，每一层的作用

4 https的协议

5 在网页上输一个网址，设计到的处理过程

6 http协议处于七层模型的那一层





# 阿里电话面试

1 个人介绍

2 项目介绍，项目难点

3 线程和进程，线程同步

4 tcp流控制

5 用户态到内核态的切换

6调用系统函数，加载到内核过程发生了什么

7 socket网络通信过程



# 字节面试

## 一个程序从开始运行到结束的完整过程（四个过程）

1、预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。

2、编译：将预处理后的文件转换成汇编语言，生成.s文件

3、汇编：汇编变为目标代码(机器代码)生成.o的文件

4、链接：连接目标代码,生成可执行程序



![image-20210324194305880](https://i.loli.net/2021/07/25/A3qJikcW1MCdSbe.png)





```c++
#include <iostream>
#include <string>
#include <unordered_set>

/*给定任意一个字符串s,获取这个字符串的最长不重复子串

s = abcedac

abcc 

c

打印出 abced  bceda
*/

void GetStr( std::string &str)
{
	std::unordered_set<char> scs;
	std::vector<std::string> vss;
	int maxstrlength = 0;
	for (int i=0;i< str.size();++i)
	{
		for (int j=i;j< str.size();++j)
		{
			if (scs.count(str[j]) == 0)
			{//如果set中没有这个字符，说明当前字符串是无重复子串
				scs.insert(str[j]);
			}
			else
			{//如果set中有这个字符，说明当前字符已经出现过
				if (j-i+1> maxstrlength)
				{
					maxstrlength = j - i + 1;
					while (!vss.empty())
					{
						vss.pop_back();
					}
					vss.push_back(str.substr(i, j - i ));
				}
				else if (j - i + 1 == maxstrlength)
				{
					vss.push_back(str.substr(i, j - i ));
				}
				scs.clear();
				break;
			}

		}
	}
	
	for (auto s: vss)
	{
		std::cout << s << std::endl;
	}

}

int main()
{
	//std::string  s = "abcedac";
	std::string  s = "abcabc";
	GetStr(s);
    std::cout << "Hello World!\n";
}
```



![image-20210324194316604](https://i.loli.net/2021/07/25/xiIz2LMo9DYqe4n.png)



# 腾讯笔试

![img](https://i.loli.net/2021/07/25/HGlkgpouAfrM5D2.jpg)



```c++
int GetMin(int a,int b,int c)
{
	if (c<=a && c<=b)
	{
		return c;
	}
	if (a<=b && a<=c)
	{
		return a;
	}
	return b;
}

//使用动态规划的解法
int GetMinNums(int num)
{
    //设置初始值，直接返回
	if (num<=0)
	{
		return 0;
	}
	if (num == 1)
	{
		return 1;
	}
	if (num==2 || num == 3)
	{
		return 2;
	}
    //dp数组设置初始值
    //dp数组 需要一个一个数值进行计算，空间比较浪费
	vector<int> dp(num+1,0);
    //1到0变换只需要1次，1-1=0
	dp[1] = 1;
    //2到0变换需要2次，2-1-2=0或则2/2-1=0
	dp[2] = 2;
    //3到0变换需要2次，3/3-1=0
	dp[3] = 2;
	for (int i=4;i<=num;++i)
	{
		int tmp1 = INT_MAX;
		if (i%2==0)
		{
			tmp1 = dp[i / 2] ;
		}
		int tmp2 = INT_MAX;
		if (i % 3 == 0)
		{
			tmp2 = dp[i / 3] ;
		}
        //dp[i]的值是三个变换的最小值+1
        //如dp[6] = Min(dp[5],dp[3],dp[2])+1
		dp[i] = GetMin(dp[i-1], tmp1, tmp2)+1;
	}
	return dp[num];
}

int main() {
	int T;
	cin >> T;
	vector <int> vi;
	for (int i=0;i<T;++i)
	{//获取的输入数字
		int num = 0;
		cin >> num;
		vi.push_back(num);
	}

	for (int i=0;i< vi.size();++i)
	{//计算最少的变换次数
		int res =GetMinNums(vi[i]);
		cout << res << endl;
	}

}
```

```C++
#include <iostream>
#include <unordered_map>
#include <queue>

using namespace std;

int main()
{
	int tt;
	scanf("%d", &tt);
	while (tt--) {
		int nn;
		scanf("%d", &nn);
        //dp中存储的是目标数变换到该数需要的最少次数
        //如dp[10] = 0,即10到10最少需要0次
        //dp[9] = 1,即10到9最少需要1次
		unordered_map<int, int> dp;
		queue<int> que;
		dp[nn] = 0;
		que.push(nn);
		while (!que.empty()) {
			int n = que.front(); que.pop();
			//cout << "tmp == " << n << endl;
			if (n == 0) {
				cout << dp[n] << "\n";
				break;
			}
			if (dp.count(n - 1) == 0) {
				dp[n - 1] = dp[n] + 1;
				que.push(n - 1);
			}
			if (n % 2 == 0 && dp.count(n / 2) == 0) {
				dp[n / 2] = dp[n] + 1;
				que.push(n / 2);
			}
			if (n % 3 == 0 && dp.count(n / 3) == 0) {
				dp[n / 3] = dp[n] + 1;
				que.push(n / 3);
			}
		}
	}
	return 0;
}
```



![img](https://i.loli.net/2021/07/25/xh1FBZvDOp9f43T.jpg)



```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

//先把所有数组合并后排序，时间复杂度较高
int GetMinKNum(vector<int> vi,vector<vector<int>> vvi)
{
	int k = vi[vi.size() - 1];
	vector<int> res;

	for (int i=0;i< vi.size() - 1;++i)
	{
		vector<int> tmp = vvi[vi[i] - 1];
		for (auto t:tmp)
		{
			res.push_back(t);
		}
	}
	sort(res.begin(), res.end());
	if (k<=res.size())
	{
		return res[k - 1];
	}
	return -1;

}

//不用对合并后的数组排序，复杂度较低
int GetMinKNum1(vector<int> vi, vector<vector<int>> vvi)
{
	int pos[10020];
	memset(pos, 0, sizeof(pos));
	int k = vi[vi.size() - 1];
	vector<int> res;

	//vi.size() - 1,要合并的数组个数
	int arrnums = vi.size() - 1;
	
	//第k小的元素，循环k次
	int mintmp = INT_MAX;
	for (int i=0;i<k;++i)
	{
		int index = -1;
		mintmp = INT_MAX;
		//每次从数组中找到一个最小元素，并且该数组的读取下标加1，循环k次mintmp即是第k小的元素
		for (int j=0;j< arrnums;++j)
		{
			//vi[j]是要合并的数组，vi[j]-1是要合并的数组下标
			int data = vvi[vi[j] - 1][pos[vi[j] - 1]];
			if (data< mintmp)
			{
				mintmp = data;
				//获取数组下标
				index = j;
			}
		}
	
		if (index == -1)
		{
			break;
		}
	
		pos[vi[index] - 1] ++ ;
	}
	
	return mintmp;

}

int main()
{
	int n, ans = 0;
	cin >> n;
	vector<vector<int>> vvi;
	for (int i = 0; i < n; i++) {
		int x; 
		scanf("%d", &x);
		vector<int> tmp;
		for (int k=0;k<x;++k)
		{
			int b;
			scanf("%d", &b);
			tmp.push_back(b);
		}
		vvi.push_back(tmp);
	}


	int q;
	cin >> q;
	vector<vector<int>> vvi1;
	for (int i = 0; i < q; i++) {
		int p;
		scanf("%d", &p);
		vector<int> tmp;
		for (int k = 0; k < p; ++k)
		{
			int b;
			scanf("%d", &b);
			tmp.push_back(b);
		}
		int tb = 0;
		scanf("%d", &tb);
		tmp.push_back(tb);
		vvi1.push_back(tmp);
	}
	
	for (int i=0;i< vvi1.size();++i)
	{
		int res = GetMinKNum(vvi1[i], vvi);
		cout << res << endl;
	}
	return 0;

}
```



```c++
#include <iostream>
#include <unordered_map>
#include <queue>

int b[10020];
int pos[10020];

using namespace std;

int main()
{
	int n;
	scanf("%d", &n);
	vector<vector<int>> a(n);
	for (int i = 0; i < n; i++) {
		int m;
		scanf("%d", &m);
		a[i].resize(m);
		for (int j = 0; j < m; j++) {
			scanf("%d", &a[i][j]);
		}
		sort(a[i].begin(), a[i].end());
	}
	int q;
	scanf("%d", &q);
	while (q--) {
		int p, k;
		scanf("%d", &p);
		for (int i = 0; i < p; i++) {
			scanf("%d", &b[i]);
		}
		scanf("%d", &k);
		int index, Min;
		memset(pos, 0, sizeof(pos));
		while (k--) {
			index = -1;
			Min = INT_MAX;
			for (int i = 0; i < p; i++) {
				int x = b[i] - 1;
				int y = pos[b[i] - 1];
				if (y >= (int)a[x].size()) continue;
				if (a[x][y] < Min) {
					Min = a[x][y];
					index = i;
				}
			}
			if (index == -1) {
				break;
			}
			pos[b[index] - 1]++;
		}
		cout << Min << "\n";

	}
	return 0;

}
```



![img](https://i.loli.net/2021/07/25/VP5O3zesXFpbvuM.jpg)



```C++
#include <iostream>
#include <unordered_map>
#include <queue>

const int N = (int)1e5 + 10;

struct Node {
	int x, y;
}a[N];

using namespace std;

int main()
{
	int n = 0, w = 0;
	scanf("%d %d", &n, &w);
	for (int i = 0; i < n; i++) {
		scanf("%d %d", &a[i].x, &a[i].y);
	}
	sort(a, a + n, [&](const Node& foo, const Node& bar) {return foo.y < bar.y; });
	cout << a[n / 2].y << endl;
	return 0;
}
```

![img](https://i.loli.net/2021/07/25/ky47NWbKrHO9sCT.jpg)

# 腾讯一面

vector是如何实现的

## 用C++实现一个简单的vector

```c++
//实现一个vector
template <typename T>
class MyVector
{
public:

	typedef T * iterator;

	//无参构造函数
	MyVector()
	{
		my_capacity = 0;
		my_size = 0;
		buffer = nullptr;
	}

	MyVector(size_t size)
	{
		my_capacity = size;
		my_size = size;
		buffer = new T[size];
	}
	MyVector(size_t size, const T & initial)
	{
		my_size = size;
		my_capacity = size;
		buffer = new T[size];
		for (size_t i = 0; i < size; ++i)
			buffer[i] = initial;
	}
	//拷贝构造函数
	MyVector(const MyVector<T> & v)
	{
		my_size = v.my_size;
		my_capacity = v.my_capacity;
		buffer = new T[my_size];
		for (size_t i = 0; i < my_size; ++i)
			buffer[i] = v.buffer[i];
	}

	MyVector&operator=(const MyVector<T> & v)
	{
		if (&that != this)
		{
			delete[] buffer;
			my_size = v.my_size;
			my_capacity = v.my_capacity;
			buffer = new T[my_size];

			for (size_t i = 0; i < my_size; ++i)
				buffer[i] = v.buffer[i];
		}
		return *this;
	}

	//析构函数
	~MyVector()
	{
		if (buffer)
		{
			delete[] buffer;
			buffer = nullptr;
		}

	}

	size_t size()const
	{
		return my_size;
	}

	size_t capacity()const
	{
		return my_capacity;
	}


	iterator begin()
	{
		return buffer;
	}

	iterator end()
	{
		return buffer + size();
	}

	T & front()
	{
		return buffer[0];
	}

	T & back()
	{
		return buffer[my_size - 1];
	}

	void push_back(const T & value)
	{
		if (my_size == my_capacity) {
			T* temp = new T[2 * my_capacity];

			// copying old array elements to new array
			for (int i = 0; i < my_capacity; i++) {
				temp[i] = buffer[i];
			}

			// deleting previous array
			delete[] buffer;
			capacity *= 2;
			buffer = temp;
		}

		// Inserting data
		arr[my_size] = data;
		my_size++;

	}


	// function to add element at any index
	void push(int data, int index)
	{
		// if index is equal to capacity then this
		// function is same as push defined above
		if (index == capacity)
			push(data);
		else
			arr[index] = data;
	}


	void pop_back()
	{
		my_size--;
	}

private:
	//arr指向分配的内存
	T* buffer;

	//capacity为vector的容量
	size_t my_capacity;

	//current是元素的数量
	size_t my_size;
};
```

1 2 3  4 5 6
4 5 6  1 2 3

## 二分查找

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int middle=0,left = 0,right= nums.size()-1;
        while(left<=right)
        {
            middle = left+(right-left)/2;
            if(nums[middle] ==target )
            {
                return middle;
            }
            else if(nums[middle] <target )
            {
                left = middle+1;
            }
            else{
                right = middle-1;
            }
        }
        return -1;
    }
};


```

```c++
/*
搜索旋转排序数组
示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1
*/

class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(!nums.size())
        {
            return -1;
        }

        if(nums.size() == 1)
        {
            return nums[0] == target? 0:-1;
        }
    
        int size = nums.size();
        int left =0,right = size-1;
        while(left<=right)
        {
            int middle = left+(right-left)/2;
            if(nums[middle] == target)
            {
                return middle;
            }
            if(nums[left]<=nums[middle])
            {//前半部分有序
                if(target>=nums[left] && target<nums[middle])
                {
                    right = middle-1;
                }
                else{
                    left=middle+1;
                }
            }
            else
            {//后半部分有序
                if(target>nums[middle] && target<=nums[right])
                {
                    left=middle+1;
                }
                else{
                    right = middle-1;
                }
            }
    
        }
    
        return -1;
    }

};
```



## 看过的书籍

深入理解计算机系统

算法导论

Effective c++

STL源码剖析 

C++ primer

计算机网络自顶向下



## 开源项目的源码



# 快手一面

IO多路复用？

红黑树和B+树区别

map和underordered_map区别

容器内存池分配？

https://leetcode-cn.com/problems/copy-list-with-random-pointer/





# 阿里巴巴校园招聘

https://campus.alibaba.com/myJobApply.htm?saveResume=yes&t=1614946039379



# 旷世一面

2021/03//3







# 百度一面

2021/03/02 16点

## 1 个人介绍

## 2 问题

### 1 实现单例模式（线程安全）

**Meyers Singleton**

局部静态变量不仅只会初始化一次，而且还是线程安全的。

注意：在C++11之前，在多线程环境下local static对象的初始化并不是线程安全的。具体表现就是：如果一个线程正在执行local static对象的初始化语句但还没有完成初始化，此时若其它线程也执行到该语句，那么这个线程会认为自己是第一次执行该语句并进入该local static对象的构造函数中。这会造成这个local static对象的重复构造，进而产生**内存泄露**问题。所以，local static对象在多线程环境下的重复构造问题是需要解决的。

C++11则在语言规范中解决了这个问题。C++11规定，在一个线程开始local static 对象的初始化后到完成初始化前，其他线程执行到这个local static对象的初始化语句就会等待，直到该local static 对象初始化完成。

```c++
#include <iostream>
using namespace std;

class Singleton
{
public:
	// 注意返回的是引用
	static Singleton& getInstance()
	{
		static Singleton value;  //静态局部变量
		return value;
	}

private:
	Singleton() = default;
	Singleton(const Singleton& other) = delete; //禁止使用拷贝构造函数
	Singleton& operator=(const Singleton&) = delete; //禁止使用拷贝赋值运算符
};

int main()
{
	Singleton& s1 = Singleton::getInstance();
	cout << &s1 << endl;

	Singleton& s2 = Singleton::getInstance();
	cout << &s2 << endl;
	
	return 0;

}


```



单例模式 只允许存在唯一的对象实例。
1）禁止在类的外部创建对象：私有构造函数
2）类自己维护唯一的对象：静态成员变量
3）提供该对象的访问的方法：静态成员函数
4）创建方式

 --》饿汉式：无论用不用，程序启动即创建

```c++
//单例模式：饿汉式
#include <iostream>
using namespace std;
class A{
public:
	//3）提供该对象的访问方法
	static A& getInstance(void){
		return s_instance;
	}
	void print(void){
		cout << m_data << endl;
	}
private:
	//1)私有化所有的构造函数
	A(int data = 0):m_data(data){}
	A(const A&);
	int m_data;
	//唯一对象
	static A s_instance;
};
A A::s_instance(1234);

int main(void)
{
	A& a1 = A::getInstance();
	A& a2 = A::getInstance();
	cout << &a1 << ' ' << &a2 << endl;
	a1.print();
	a2.print();
	return 0;
}
  --》懒汉式：用的时候创建，不用了即销毁

//单例模式：懒汉式
#include <iostream>
using namespace std;
class A{
public:
	//3）提供该对象的访问方法
	static A& getInstance(void){
		if(!s_instance)
			s_instance = new A(1234);
		++s_counter;
		return *s_instance;
	}
	void release(void){
		if(s_counter && --s_counter == 0){
			delete this;//自销毁
			s_instance = NULL;
		}
	}
	void print(void){
		cout << m_data << endl;
	}
private:
	//1)私有化所有的构造函数
	A(int data = 0):m_data(data){
		cout << "构造函数" << endl;
	}
	~A(void){
		cout << "析构函数" << endl;
	}
	A(const A&);
	int m_data;
	//唯一对象
	static A* s_instance;
	//记录使用单例对象的人数
	static int s_counter;
};
A* A::s_instance = NULL;
int A::s_counter = 0;

int main(void)
{
	A& a1 = A::getInstance();//-->new A
	A& a2 = A::getInstance();
	A& a3 = A::getInstance();
	cout << &a1 << ' ' << &a2 << ' ' << &a3 << endl;
	a1.print();
	a1.release();
	a2.print();
	a3.print();
	a2.release();
	a3.release();//--delete
	return 0;

}
```

懒汉式和饿汉式都不是线程安全的，都可以通过加锁实现线程安全，线程安全最简单的方式是第一种（C++11之后支持）

参考：https://blog.csdn.net/chenxun_2010/article/details/48273723



### 2 反转链表leetcode



### 3 数组和链表的区别





# 字节一面+二面

## 1 个人介绍

## 2 项目介绍，主要负责什么？

## 3 问题

###  1 重新实现一个更“优”的 string

要求： 

​	（1）对外的行为表现与std::string 完成一致

​	（2）优化点是：复制的时候仅复制引用，只有在修改内容时，才复制内容

​	（3）线程安全

基础版本1：

```c++
#include <iostream>
#include <cstring>
using namespace std;

class String{
public:
	//构造函数
	String(const char* str = ""):
		m_str(strcpy(new char[strlen(str)+1],str)){}
	//析构函数
	~String(void){
		delete[] m_str;
		m_str = NULL;
	}
	//拷贝构造:深拷贝
	String(const String& that):
		m_str(strcpy(
			new char[strlen(that.m_str)+1],
			that.m_str)){}
	//深拷贝赋值
	String& operator= (const String& that){
		if(&that != this){
			/*小鸟：
			delete[] m_str;
			m_str = new char[strlen(that.m_str)+1];
			strcpy(m_str,that.m_str);*/
			/*大鸟*/
			char* str = 
				new char[strlen(that.m_str)+1];
			delete[] m_str;
			m_str = strcpy(str,that.m_str);
			/*老鸟
			  复用深拷贝拷贝构造和析构
			String temp(that);//深拷贝构造,temp是i2的临时对象
			swap(m_str,temp.m_str);*/
		}////遇到花括号}调用析构函数,施放临时对象

		return *this;
	}
	
	//提供访问接口
	const char* c_str(void)const{
		return m_str;
	}

private:
	char* m_str;
};
int main(void)
{
	String s1("hello world");
	cout << s1.c_str() << endl;
	String s2(s1);
	cout << s2.c_str() << endl;
	String s3("hello C++");
	s2 = s3;//拷贝赋值
	cout << s2.c_str() << endl;//hello C++
	return 0;
}
```





### 2  实现智能指针

### 3 线程和进程的区别

### 4 线程之间的通信方式、进程之间的通信方式

### 5 输入为字符串，输出为数字，如何设计实现？

"ADD(1,1)" => 2

"SUB(1110, 0)" => 1110

"ADD(SUB(20,1),ADD(1,1))" => 21

"ADD(SUB(10,ADD(1,1)), 10)" => 18

### 6 在windows下创建子进程使用什么命令

### 7 线程同步中信号量如何使用？

### 7 进程同步中消息队列如何使用？





# 快手一面+二面

## 1 个人介绍

## 2 项目介绍，主要负责什么？

## 3 问题

### （1）实现一个线程安全的队列  class MyQueue{}

###  （2）python的一些基础知识

###  （3）实现pow(x,n)函数，计算x的n次数，以及如何进行优化

### （4）子进程如何创建，如何根据线程id对子进程和父进程进行区分

### （5）创建线程后，如何得到线程的返回值

### （6） 线程和进程的区别



# 滴滴一面



## 1 个人介绍

## 2 项目介绍，主要负责什么？

## 3 问题

### 1 TCP协议和IP协议有什么区别？

TCP协议
TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的{传输层}通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。

IP协议
IP（Internet Protocol）协议的英文名直译就是：因特网协议。从这个名称我们就可以知道IP协议的重要性。在现实生活中，我们进行货物运输时都是把货物包装成一个个的纸箱或者是集装箱之后才进行运输，在网络世界中各种信息也是通过类似的方式进行传输的。IP协议规定了数据传输时的基本单元和格式。如果比作货物运输，IP协议规定了货物打包时的包装箱尺寸和包装的程序。 除了这些以外，IP协议还定义了数据包的递交办法和路由选择。同样用货物运输做比喻，IP协议规定了货物的运输方法和运输路线。 IP协议属于TCP/IP协议族网络层的协议


### 2  常见的STL容器

A.线性容器：向量(vector)、双端队列(deque)、列表(list)
B.适配器容器：堆栈(stack)、队列(queue)、优先队列(priority_queue)
C.关联容器：映射(map)、多重映射(multimap)、集合(set)、多重集合(multiset)

### 3 常见的数据结构

链表,栈与队列,树

### 4 如何判断一个链表是否有环

https://leetcode-cn.com/problems/linked-list-cycle/

方法一：哈希表
思路及算法

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```
class Solution {

public:

  bool hasCycle(ListNode *head) {

​    unordered_set<ListNode*> nodes;

​    while(head)

​    {

​      if(nodes.count(head))

​      {

​        return true;

​      }

​      nodes.insert(head);

​       head = head->next;

​    }

​    return false;

  }

  

};
```

方法二：龟兔算法

具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```
class Solution {

public:

  bool hasCycle(ListNode *head) {

​    if(!head || !head->next)

​    {

​      return false;

​    }

​    ListNode * slow = head;

​    ListNode * fast = head->next;

​    while(slow!=fast)

​    {

​      if(!fast ||!fast->next)

​      {

​        return false;        

​      }



​      slow = slow->next;

​      fast = fast->next->next;

​    }



​    return true;

  }

  

};
```



### 5 leetcode两数之和

https://leetcode-cn.com/problems/two-sum/

方法一：暴力枚举
思路及算法

最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。

当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};
    }
};
```

方法二：哈希表
思路及算法

注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
    	//key为vector中的值，value为vector中值的下标（因为返回的就是两个下标）
        unordered_map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};

```





# 阿里一面

2021/02/27  下午1点半到4点

## 1 个人介绍

## 2  问题回答

### （1）虚拟内存和内存，为什么用虚拟内存

电脑中所运行的程序均需经由内存执行，若执行的程序占用内存很大或很多，则会导致内存消耗殆尽。为解决该问题，Windows中运用了虚拟内存技术，即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。

内存（物理内存）就是你的机器本身内存（如内存条的大小）

### （2）在父进程中创建的static 变量在子进程中是否可以用？

​       创建的子进程相当于对父进程的资源进行了拷贝，在子进程中也会创建一个static 变量，两个变量互不影响

​       在进程中创建线程，该线程使用进程的资源，在线程中对static变量的修饰在进程中也可以看到。



### （3） 进程和线程的区别，进程和程序的区别



**进程是资源分配的最小单位，线程是CPU调度的最小单位**



程序是静态的指令集合，而进程是运行中的指令集合，是进行的程序

进程是运行中的程序，线程是进程的内部的一个执行序列

进程是资源分配的单元，线程是执行单元

进程间切换代价大，线程间切换代价小

进程拥有资源多，线程拥有资源少

多个线程共享进程的资源



线程也有**就绪**、**阻塞**和**运行**三种基本状态。**就绪状态**是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；**运行状态**是指线程占有处理机正在运行；**阻塞状态**是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。



### （4）linux文件系统



Linux文件系统采用的是树形结构，从根目录root（/）开始。



### （5） 进程间有哪些通信方式？

进程可以通过管道、套接字、信号交互、共享内存、消息队列等等进行通信；而线程本身就会共享内存，指针指向同一个内容，交互很容易。

### （6）进程有多少种状态？

进程包括三种状态：就绪态、运行态和阻塞态。详细说明如下：

就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；

2）执行——阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；

> 当进程进入阻塞状态，是不占用CPU资源的。

3）阻塞——就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；

4）执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。

### （7）线程有多少种状态，状态之间如何转换

操作系统线程的5种状态： 

1.    新建状态：
      线程创建但没有启动  
2.    就绪状态：
      线程处于可运行的状态，当线程获得CPU的时间片后会被执行，时间片耗尽或主动放弃**当次**时间片（yield方法）时再次进入就绪状态。  
3.    运行状态：
      线程得到时间片被CPU执行  
4.    阻塞状态：
      线程放弃CPU的时间片（一直到某个条件达成），主动进入阻塞的状态。  

- 同步阻塞：线程由于尝试获得对象的同步锁但无法取得时，进入锁池，等待其他线程释放该对象的锁。  

- 等待阻塞：线程主动放弃对对象上的锁的占用，进入等待对象通知的队列。指wait方法  

- 其他阻塞：线程主动进入休眠状态，等待条件达成。指sleep、join方法或I/O请求。  

  5    终止状态：
   线程任务结束或异常退出

![image-20210228154515551](https://i.loli.net/2021/07/25/E528r9hoauzLMYQ.png)



### （8）Linux 下如何查看进程占用的内存空间，使用什么命令，在哪一列？

ps命令

top命令

- %CPU：进程占用CPU的使用率
- %MEM：进程使用的物理内存和总内存的百分比

### （9）进程间时如何进行切换的

如果想要从A进程切换到 B 进程，必定要先从用户态切换到内核态，因为这个切换的工作你不能让用户进程去实现，不然当 CPU 在用户进程手上的时候，他可以选择一直执行，不让出 CPU，这肯定是不允许的。所以操作系统需要先挂起正在占用 CPU 的 A 进程，才能切换到 B 进程。

由于从用户态切换到内核态的时候，CPU 是在用户进程手中，所以这个是通过硬中断来实现的。在从用户态切换到内核态之前需要保存用户进程的上下文，以便下一次执行时可以继续之前的工作。

这个上下文就是进程执行的环境，包括所有的寄存器变量，进程打开的文件、内存信息等。一个进程的上下文可以分为用户级上下文，寄存器上下文，系统级上下文。用户级上下文存储的是用户进程的内存数据以及堆栈数据等；寄存器上下文是一些通用寄存器；系统级上下文是内核栈、PCB (进程控制块)等。

### （10）自旋锁和互斥锁的区别

自旋锁是一种互斥锁的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock）则是不断循环并测试锁的状态，这样就一直占着cpu。

互斥锁：用于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。

临界区：每个进程中访问临界资源的那段程序称为临界区，每次只允许一个进程进入临界区，进入后不允许其他进程进入。

自旋锁：与互斥量类似，它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等(自旋)阻塞状态。用在以下情况：锁持有的时间短，而且线程并不希望在重新调度上花太多的成本。"原地打转"。

自旋锁与互斥锁的区别：线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态。

信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。



### （11）在线程中，如何进行同步

临界区（Critical Section）、互斥对象（Mutex）：主要用于互斥控制；都具有拥有权的控制方法，只有拥有该对象的线程才能执行任务，所以拥有，执行完任务后一定要释放该对象。

信号量（Semaphore）、事件对象（Event）：事件对象是以通知的方式进行控制，主要用于同步控制！

### （12）平衡二叉树的特点

平衡二叉树特点：

（1）非叶子节点最多拥有两个子节点；

（2）非叶子节值大于左边子节点、小于右边子节点；

（3）树的左右两边的层级数相差不会大于1;

（4）没有值相等重复的节点;



### （13）平衡二叉树和普通二叉树的区别

​	没有平衡二叉树的一些限制

### （14）为什么平衡二叉树左右子树的高度不超过1

二叉树退化成单链表，搜索效率降低为 O(n)。

二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。

可以看出当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。
这种左右子树的高度相差不超过 1 的树为平衡二叉树。

### （15）数组和链表的优势和劣势

数组的优点

- 随机访问性强
- 查找速度快

数组的缺点

- 插入和删除效率低
- 可能浪费内存
- 内存空间要求高，必须有足够的连续内存空间。
- 数组大小固定，不能动态拓展

链表的优点

- 插入删除速度快
- 内存利用率高，不会浪费内存
- 大小没有固定，拓展很灵活。

链表的缺点

- 不能随机查找，必须从第一个开始遍历，查找效率低

### （15）static修饰符的作用



**静态全局变量**

**静态全局变量和普通全局变量都是静态存储方式，存储方式相同；**

**静态全局变量和普通全局变量的作用域不同，静态全局变量只在该变量的源文件内有效；普通全局变量在整个源程序，包括多个源文件内有效。**



**静态局部变量**

**静态局部变量和非静态局部变量存储方式不同，静态局部变量存储在静态存储区间，变量的值可保存到下一次调用，普通局部变量存储在栈上，函数调用完成即销毁；**

**静态局部变量和非静态局部变量的局部作用域一样。**



**静态函数** 

**静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用；**



**类的静态成员变量**



在C++中，静态成员是属于整个类而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。**使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏（相比于全局变量）的原则，保证了安全性还可以节省内存**。 
类的静态成员，属于类，也属于对象，但终归是属于类。

**static成员使用时必须初始化，且只能类外初始化**。 
可以通过类名访问（无对象生成时亦可），也可以通过对象访问。



**类的静态成员函数**

静态成员函数属于类，而不属于对象，**没有this指针**。

 静态成员函数只能访问静态数据成员。原因在于：非静态成员函数，在调用时，this指针被当做参数传进。

静态成员函数的意义，不在于信息共享、数据沟通，而是在于管理静态数据成员，完成对静态数据成员的封装。 





### （16）virtual修饰符的作用

虚函数，当使用基类的指针p指向派生类的对象时，会调用子类的函数，实现多态。

虚继承，避免钻石继承

为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

多继承（Multiple Inheritance）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。

多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示：![image-20210228161325335](https://i.loli.net/2021/07/25/ZKOAro8syiBHcUu.png)

类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A-->B-->D 这条路径，另一份来自 A-->C-->D 这条路径。

在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A -->B-->D 这条路径，还是来自 A-->C-->D 这条路径。

为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

在继承方式前面加上 virtual 关键字就是虚继承

### （17）B树

B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个）

B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；

B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

B\*在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；

### （18）new和malloc的区别

new、delete 是操作符，可以重载，只能在 C++中使用。malloc、free 是函数，可以覆盖，C、C++中都可以使用。

new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数

new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。

malloc 申请的内存空间要用 free 释放，而 new 申请的内存空间要用 delete 释放，不要混用。因为两者实现的机理不同

### （19）用过的虚拟化技术，docker的核心，主要使用场景及优势

最流行的容器系统Docker，即属于操作系统级虚拟化，多个虚拟环境之间可以相互隔离。

容器技术还可以更高效地使用系统资源，由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。此外，容器还具有更快速的启动时间，传统的虚拟机技术启动应用服务往往需要数分钟，而对于容器由于，直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间，大大的节约了应用开发、测试、部署的时间。

### （20）中断

中断是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断。

通常，在接收到来自外围硬件和内存的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件／软件处理。发出这样的信号称为进行[中断请求](https://zh.wikipedia.org/w/index.php?title=中断请求&action=edit&redlink=1)（interrupt request，IRQ）。硬件中断导致处理器通过一个[运行信息切换](https://zh.wikipedia.org/wiki/上下文交換)（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为CPU指令集中的一个指令，以可编程的方式直接指示这种运行信息切换，并将处理导向一段中断处理代码

中断是用以提高计算机工作效率、增强计算机功能的一项重要技术。最初引入硬件中断，只是出于性能上的考量。如果计算机系统没有中断，则处理器与外部设备通信时，它必须在向该设备发出指令后进行忙等待（Busy waiting），反复轮询该设备是否完成了动作并返回结果。这就造成了大量处理器周期被浪费。引入中断以后，当处理器发出设备请求后就可以立即返回以处理其他任务，而当设备完成动作后，发送中断信号给处理器，后者就可以再回过头获取处理结果。这样，在设备进行处理的周期内，处理器可以执行其他一些有意义的工作，而只付出一些很小的切换所引发的时间代价



3 项目介绍

项目中有没有遇到一些比较棘手的问题，如何解决的？



4 做题，手撕区间合并算法

https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/



# 美团一面

2012/02/25 11点-11点40 

1 个人介绍

2 项目介绍

3 滑动窗口

给定整型数组,长度为m,给定一个窗口长度为m，m远小于n，窗口每次从数组开始向末尾移动一位，给出每次移动窗口的最大值

```c++
//返回窗口中的最大值
int MaxNum(int *p_start,int *p_end)
{
    
    return 0;
}

//p_num为传进去的整型数组，n为数组长度，m是窗口长度
void MoveWindow(int *p_num,int n,int m)
{
    for(int start=0,end=m;end<n;start++,end++)
    {//每次窗口向后移动一位
        int maxvalue = MaxNum(p_num+start,p_num+start+m)；
         std::cout<<maxvalue<<std::endl;
    }
    return;
}

```

leetcode链接：https://leetcode-cn.com/problems/sliding-window-maximum/



4 排序算法

都知道什么排序算法？  

快速排序如何实现的



**1.static****有什么用途****(****作用****)****？（请至少说明两种）**

  1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。

  2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个**本地的全局变量。**

3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被**限制在声明它的模块的本地范围内使用**

**static****全局变量与普通的全局变量有什么区别：****static****全局变量只初使化一次，防止在其他文件单元中被引用****;**

  **static****局部变量和普通局部变量有什么区别：****static****局部变量只被初始化一次，下一次依据上一次结果值；**

**static****函数与普通函数有什么区别：****static****函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝**

 

2.**引用与指针有什么区别？**

  1) 引用必须被初始化，指针不必。

  2) 引用初始化以后不能被改变，指针可以改变所指的对象。

3) 不存在指向空值的引用，但是存在指向空值的指针。

**7. “****引用”与指针的区别是什么？** 

指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。此外，就是上面提到的对函数传ref和pointer的区别。 

2、指针和引用的区别？

1）指针可以不做初始化，其目标可以在初始化以后随意改变（除非指针常量）而引用必须初始化，且一旦初始化，其所引用目标不能再改变。

2）可以定义指针的指针（二级指针），但是不能定义引用的指针。（不能对别名取别名）

3）可以定义指针的引用，不能定义引用的引用。

4）可以定义指针数组，但是不能定义引用数组，可以定义数组引用，用来引用一个数组，给一个数组取别名。

5）和函数指针一样，可以定义函数引用，语法特征和指针完全相同。例如形式：void (&rfunc)(int ,int) = func;

**8.** **什么时候需要“引用”？** 

流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。 

 

 

3.描述**实时系统的基本特性**

​    在特定时间内完成特定的任务，实时性与可靠性。

4**.****全局变量和局部变量在内存中是否有区别**？如果有，是什么区别？

   全局变量储存在静态数据库，局部变量在堆栈。

5.什么是平衡二叉树？

   左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。

6.**堆栈溢出**一般是由什么原因导致的？

   **没有回收垃圾资源。**

7.什么函数不能声明为虚函数？

​    **Constructor****构造函数不能声明为虚函数。**

8.冒泡排序算法的时间复杂度是什么？

   时间复杂度是O(n^2)。

9.**写出****float x** **与“零值”比较的****if****语句。**

   **if(x>0.000001&&x<-0.000001)**

10.Internet采用哪种网络协议？该协议的主要层次结构？

   Tcp/Ip协议

   主要层次结构为： 应用层/传输层/网络层/数据链路层/物理层。

11.Internet物理地址和IP地址转换采用什么协议？

   ARP (Address Resolution Protocol)（地址解析協議）

12.IP地址的编码分为哪俩部分？

   IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。

13.用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。

   循环链表，用取余操作做

14.不能做switch()的参数类型是：

   switch的参数不能为实型。// 还有字符串

15、头文件中的 ifndef/define/endif 干什么用？

**防止该头文件被重复引用。**

16、#include 和 #include “filename.h” 有什么区别？

对于#include<filename.h，编译器从标准库路径开始搜索filename.h

对于#include“filename.h”，编译器从用户的工作路径开始搜索filename.h

 

17、const 有什么用途？（请至少说明两种）

```
类型修饰符：定义常量，类型检查，保护被修饰符不被修改，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝，#define给出的是立即数，#define定义的常量在内存中有若干个拷贝。 
```

 

18、**在****C++** **程序中调用被** **C****编译器编译后的函数，为什么要加** **extern** **“****C****”声明？**

```
函数经过编译系统的翻译成汇编，函数名对应着汇编标号。因为C编译函数名与得到的汇编代号基本一样，如：fun()=>_fun, main=>_main但是C++中函数名与得到的汇编代号有比较大的差别。如：由于函数重载，函数名一样，但汇编代号绝对不能一样。为了区分，编译器会把函数名和参数类型合在一起作为汇编代号，
```

这样就解决了重载问题。具体如何把函数名和参数类型合在一起，要看编译器的帮助说明了。这样一来，如果C++调用C，如fun(),则调用名就不是C的翻译结果_fun,而是带有参数信息的一个名字，因此就不能调用到fun（），为了解决这个问题，加上extern "C"表示该函数的调用规则是C的规则，则调用时就不使用C++规则的带有参数信息的名字，而是_fun,从而达到调用C函数的目的

面试题 1：变量的声明和定义有什么区别

为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。

说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。

面试题 2：sizeof 和 strlen 的区别

sizeof 和 strlen 有以下区别： sizeof 是一个操作符，strlen 是库函数。

sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\ 0‘的字符串作参数。

编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。并且 sizeof计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。strlen的它没有包括字符串末尾的'\0'

 

数组做 sizeof 的参数不退化，传递给 strlen 就退化为指针了。

注意：有些是操作符看起来像是函数，而有些函数名看起来又像操作符，这类容易混淆的名称一定要加以区分，否则遇到数组名这类特殊数据类型作参数时就很容易出错。最容易混淆为函数的操作符就是 sizeof。

面试题 3.：C 语言的关键字 static 和 C++ 的关键字 static 有什么区别

在 C 中 static 用来修饰局部静态变量和外部静态变量、函数。而 C++中除了上述功能外，还用来定

义类的成员变量和函数。即静态成员和静态成员函数。

注意：编程时 static 的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息。

面试题 4：Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别

malloc 和 new 有以下不同：

（1）new、delete 是操作符，可以重载，只能在 C++中使用。

（2）malloc、free 是函数，可以覆盖，C、C++中都可以使用。

（3）new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。

（4）malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数

（5）new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。

注意：malloc 申请的内存空间要用 free 释放，而 new 申请的内存空间要用 delete 释放，不要混用。因为两者实现的机理不同。

面试题 5：简述 C、C++程序编译的内存分配情况

C、C++中内存分配方式可以分为三种：

（1）从静态存储区域分配：

内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快、不容易出错，因为有系统会善后。例如全局变量，static 变量等。

（2）在栈上分配：

在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

（3）从堆上分配：

即动态内存分配。程序在运行的时候用 malloc 或 new 申请任意大小的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活。 如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。

一个 C、C++程序编译时内存分为 5 大存储区：堆区、栈区、全局区、文字常量区、程序代码区。

**16.C****和C++有什么不同?**

从机制上：c是面向过程的（但c也可以编写面向对象的程序）；c++是面向对象的，提供了类。但是，

c++编写面向对象的程序比c容易

从适用的方向：c适合要求代码体积小的，效率高的场合，如嵌入式；c++适合更上层的，复杂的； llinux核心大部分是c写的，因为它是系统软件，效率要求极高。

从名称上也可以看出，c++比c多了+，说明c++是c的超集；那为什么不叫c+而叫c++呢，是因为c++比

c来说扩充的东西太多了，所以就在c后面放上两个+；于是就成了c++

C语言是结构化编程语言，C++是面向对象编程语言。

C++侧重于对象而不是过程，侧重于类的设计而不是逻辑的设计。

 

面试题 6：简述 strcpy、sprintf 与 memcpy 的区别 补充：memset

三者主要有以下不同之处：

（1） 操作对象不同， strcpy 的两个操作对象均为字符串， sprintf 的操作源对象可以是多种数据类型，目的操作对象是字符串， memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。

（2）执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。

（3）实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字符串的转化，memcpy 主要是内存块间的拷贝。

说明：strcpy、sprintf 与 memcpy 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来选择合适的函数实现拷贝功能。

面试题 7：面向对象的三大特征

面向对象的三大特征是封装性、继承性和多态性：

 封装性：将客观事物抽象成类，每个类对自身的数据和方法实行 protection（private， protected，public）。

 继承性：广义的继承有三种实现形式：实现继承（使用基类的属性和方法而无需额外编码的能力)、可视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法,实现滞后到子类实现)。。前两种（类继承）和后一种（对象组合=>接口继承以及纯虚函数）构成了功能复用的两种方式。

 多态性：是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

面试题 8：C++的空类有哪些成员函数

 缺省构造函数。

 缺省拷贝构造函数。

 缺省析构函数。

 缺省赋值运算符。

 缺省取址运算符。

 缺省取址运算符 const。

面试题 9：谈谈你对拷贝构造函数和赋值运算符的认识

拷贝构造函数和赋值运算符重载有以下两个不同之处：

（1）拷贝构造函数生成新的类对象，而赋值运算符不能。

（2）由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉

注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。

面试题 10：简述类成员函数的重写、重载和隐藏的区别

（1）重写和重载主要有以下几点不同。

 范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。

 参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同。

 virtual 的区别：重写的基类中被重写的函数必须要有 virtual 修饰，而重载函数和被重载函数可以被virtual 修饰，也可以没有。

（2）隐藏和重写、重载有以下几点不同。

 与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。

 参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。

当参数不相同时，无论基类中的参数是否被 virtual 修饰，基类的函数都是被隐藏，而不是被重写。

说明：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。

面试题 11：简述多态实现的原理

编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。编译器还会在此类中隐含插入一个指针 vptr （对 vc 编译器来说，它插在类的第一个位置上）指向虚函数表。调用此类的构造函数时，在类的构造函数中，编译器会隐含执行 vptr 与 vtable 的关联代码，将 vptr 指向对应的 vtable，将类与此类的 vtable 联系了起来。另外在调用类的构造函数时，指向基础类的指针此时已经变成指向具体的类的 this 指针，这样依靠此 this 指针即可得到正确的 vtable，。如此才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。

注意：一定要区分虚函数，纯虚函数、虚拟继承的关系和区别。牢记虚函数实现原理，因为多态C++面试的重要考点之一，而虚函数是实现多态的基础。

面试题 12：链表和数组有什么区别

数组和链表有以下几点不同：

（1）存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个结点要保存相邻结点指针。

（2）数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点，效率低。

（3）数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。

（4）越界问题：链表不存在越界问题，数组有越界问题。

说明：在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。

10.数组和链表的区别

数组：数据顺序存储，固定大小

连表：数据可以随机存储，大小可动态改变

 

 

面试题 13：简述队列和栈的异同

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是“后进先出”。

注意：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。分配方式类似于链表。它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。

面试题 14：&&和&、||和|有什么区别

（1）&和|对操作数进行求值运算，&&和||只是判断逻辑关系。

（2）&&和||在在判断左侧操作数就能确定结果的情况下就不再对右侧操作数求值。

注意：在编程的时候有些时候将&&或|| 替换成&或|没有出错，但是其逻辑是错误的，可能会导致不可预想的后果（比如当两个操作数一个是 1 另一个是 2 时）

面试题 15：C++的引用和 C 语言的指针有什么区别

指针和引用主要有以下区别：

1) 引用本质就是指针

  double d = 3.14;

  double r = d; //==>double* const p = &d;

2) 指针可以不初始化,其目标可以在初始化以后随意改变(除了指针常量).而引用必须初始化,而且一旦初始化所引用的目标不能再改变

 int a, b;

 int* p;//可以不初始化

 p = &a;//p指向a

 p = &b;//p指向b

 =============

 int& r; //error 引用不能不初始化

 int& r = a; //r引用a

 r = b;//将b的值赋值给a

 

3) 可以定义指针的指针(二级指针),但是不能定义引用的指针

int a;

int* P = &a;

int** p = &p; //OK,二级指针

 

int& r = a;

int&* pr = &r; //error 不能使用引用的指针 语法错误

 

4) 可以定义指针的引用,不能定义引用的引用

 int a;

 int* p = &a;

 int*& rp = p; //OK 指针的引用

 

 int& r = a;

 int&& rr = r;//error 不能定义引用的引用 C++2011可以叫做右值引用

 

5) 可以定义指针的数组,但是不能定义引用的数组

  int a,b,c;

  int* parr[3]={&a, &b, &c}; //数组指针 OK

  int& rarr[3]={a,b,c}; //error

 

6) 可以定义数组引用

  int arr[3] = {1,2,3};

  int (&r)[3] = arr; //OK

  int &r[3] = arr; //error

 

7) 和函数指针一样,可以定义函数的引用,语法相同

  void func(int a,int b)

  {

​     ...

  }

  int main(void)

  {

​     void(*pfunc)(int, int) = func;

​     void(&rfunc)(int, int) = func;//函数引用

  }

 

面试题16：内联函数(inline) 

 使用inline关键字修饰的函数,表示这个函数是内联函数,编译器将尝试做内联优化,避免函数调用的开销

1) 多次调用的小而简单的函数适合内联

2) 调用次数极少或者大而复杂的函数不适合内联

3) 递归函数不适合内联

4) 内联修饰的函数只是一种建议,而不是要求,在实际的编译过程中,能否内联主要取决于编译器,有些函数不加inline关键字也会默认的处理为内联

面试题17.C++的动态内存分配 

 1) C语言: malloc/calloc/realloc free 函数

 2) C++ : new/delete 运算符

   new运算符 用于动态内存分配,delete运算符用于动态内存释放

eg C中:

int* p = (int*)malloc(sizeof(int)) 分配4个字节

   *p = 100;

   free(p);

   p = NULL;

 

eg c++:

   int* p = new int;

   *p = 100;

   delete p;

   \---------------------------

   int* p = new int(100);

   delete p;

   \---------------------------

   int* parr = new int[10];

   parr[0] = 10;

   parr[1] = 20;

   ...

   delete[] parr; //new数组 delete数组 + 返回的指针

面试题 18：typedef 和 define 有什么区别

（1）用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。

（2）执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。

（3）作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在 define 声明后的引用都是正确的。

（4）对指针的操作不同：t ypedef 和 define 定义的指针时有很大的区别。

注意：typedef 定义是语句，因为句尾要加上分号。而 define 不是语句，千万不能在句尾加分号。

 

32.请说出const与#define 相比，有何优点？

答案：1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试

面试题 19：关键字 const 是什么，static 有什么作用，关键字volatile含义

const 是一个C语言的关键字，它限定一个变量不允许被改变，用来定义一个只读的变量或对象。主要优点：便于类型检查、同宏定义一样可以方便地进行参数的修改和调整、节省空间，避免不必要的内存分配、可为函数重载提供参考。

Const的用途：1.定义变量，只能读，不能修改变量的值

​       \2. 参数列表，表示该参数不能修改其值

​       3.类中 定义一个函数()const 该常成员函数，只能被const被引用，不能修改该类的数据成员
 const关键字至少有下列n个作用：
 　（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
 　（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
 　（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
 　（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
 　（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”

 

static 在 C 中主要用于定义全局静态变量、定义局部静态变量、定义静态函数。在 C++中新增了两种作用：定义静态数据成员、静态函数成员。

Static声明变量，可以改变变量的生命周期和作用域

1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。 
 2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。 
 3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。 


注意：因为 static 定义的变量分配在静态区，所以其定义的变量的默认值为 0，普通变量的默认值为随机数，在定义指针变量时要特别注意。

volatile的作用：声明变量，这种变量可以同时被多个程序使用，作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值

volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象，没有volatile也可能能正常运行，但是可能修改了编译器的优化级别之后就又不能正常运行了

 

用volatile关键字定义变量，相当于告诉编译器，这个变量的值会随时发生变化，每次使用时都需要去内存里

重新读取它的值，并不要随意针对它作优化。

建议使用volatile变量的场所：

(1) 并行设备的硬件寄存器

(2) 一个中断服务子程序中会访问到的非自动变量（全局变量）

(3) 多线程应用中被几个任务共享的变量

20.Const的用法：

const在C语言中算是一个比较新的描述符，我们称之为常量修饰符，意即其所修饰的对象为常量

\1. 函数体内修饰局部变量

 const作为一个类型限定词，要求他所修饰的对象为常量，不可被改变，不可被赋值，不可作为左值（l-value)。

\2. 在函数声明时修饰参数

在函数参数声明中const一般用来声明指针而不是变量本身

\3. 全局变量

解决了文件间重定义的冲突


面试题 20：extern 有什么作用

extern 标识的变量或者函数声明其定义在别的文件中，提示编译器遇到此变量和函数时在其它模块中寻找其定义。

在C++ 程序中调用被 C编译器编译后的函数，为什么要加 extern “C”声明？

//extern是C/C++语言中表明函数和全局变量作用范围的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用

// extern “C是连接申明，编译时告诉编译器以下代码用C风格的方式编译和连接，其目的是实现C++与C及其它语言的混合编程。

面试题 21：流操作符重载为什么返回引用

在程序中，流操作符>>和<<经常连续使用。因此这两个操作符的返回值应该是一个仍旧支持这两个操作符的流引用。其他的数据类型都无法做到这一点。

注意：除了在赋值操作符和流操作符之外的其他的一些操作符中，如+、-、*、/等却千万不能返回引用。因为这四个操作符的对象都是右值，因此，它们必须构造一个对象作为返回值。

面试题 22：简述指针常量与常量指针区别

指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。

指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。

注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。

面试题 23：如何避免“野指针”

“野指针”产生原因及解决办法如下：

（1）指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向 NULL。

（2）指针 p 被 free  或者 delete 之后，没有置为 NULL。解决办法：指针指向的内存空间被释放后指针应该指向 NULL。

（3）指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向 NULL。

注意：“野指针”的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生“野指针”，在使用指针前一定要检验指针的合法性。

面试题 24：常引用有什么作用

常引用的引入主要是为了避免使用变量的引用时，在不知情的情况下改变变量的值。常引用主要用于定义一个普通变量的只读属性的别名、作为函数的传入形参，避免实参在调用函数中被意外的改变。

说明：很多情况下，需要用常引用做形参，被引用对象等效于常对象， 不能在函数中改变实参的值，这样的好处是有较高的易读性和较小的出错率。

 

面试题 25：构造函数能否为虚函数

构造函数不能是虚函数。而且不能在构造函数中调用虚函数，因为那样实际执行的是父类的对应函数，因为自己还没有构造好。析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。析构函数也可以是纯虚函数，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。

说明：虚函数的动态绑定特性是实现重载的关键技术，动态绑定根据实际的调用情况查询相应类的虚函数表，调用相应的虚函数。

面试题 26：谈谈你对面向对象的认识

面向对象可以理解成对待每一个问题，都是首先要确定这个问题由几个部分组成，而每一个部分其实就是一个对象。然后再分别设计这些对象，最后得到整个程序。传统的程序设计多是基于功能的思想来进行考虑和设计的，而面向对象的程序设计则是基于对象的角度来考虑问题。这样做能够使得程序更加的简洁清晰。

说明：编程中接触最多的“面向对象编程技术”仅仅是面向对象技术中的一个组成部分。发挥面向对象技术的优势是一个综合的技术问题，不仅需要面向对象的分析，设计和编程技术，而且需要借助必要的建模和开发工

6.列举几种进程的同步机制，并比较其优缺点。

原子操作

信号量机制

自旋锁

管程，会合，分布式系统

 

**21.****进程之间通信的途径**

答案：共享存储系统，消息传递系统，管道：以文件系统为基础 

**22.****进程死锁的原因**

答案：资源竞争及进程推进顺序非法 

**23.****死锁的****4****个必要条件**  答案：互斥、请求保持、不可剥夺、环路 

**24.****死锁的处理？** 

答案：鸵鸟策略、预防策略、避免策略、检测与解除死锁

**25.** **操作系统中进程调度策略有哪几种？**

答案：FCFS(先来先服务)，优先级，时间片轮转，多级反馈 

**26.****类的静态成员和非静态成员有何区别？**

答案：类的静态成员每个类只有一个，非静态成员每个对象一个？？？？？？？？？？ 

**27.****纯虚函数如何定义？使用时应注意什么？**

答案：virtual void f()=0; **是接口，子类必须要实现** 

23:多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?：

虚拟函数表是在编译期(Compile-Time )就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.

而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的,这是实现多态的关键.

 

**29.ISO****的七层模型是什么？**

tcp/udp是属于哪一层？tcp/udp有何优缺点？

答案：应用层表示层会话层运输层网络层物理链路层物理层 

tcp /udp属于运输层 

TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。

与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。 tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好 

udp: 不提供稳定的服务，包头小，开销小

15:Intertnet采用哪种网络协议，该协议的主要层次结构？

  TCP/IP协议

应用层/传输层/网络层/数字链路层/物理层。

16：IP地址有两部分组成：网络号和主机号

 

17：程序的局部变量存储在（栈）中，全局变量存储于（静态存储区），动态申请数据存储于（堆中）；

在采用段式内存管理的架构中，数据段（data  segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。  

在采用段式内存管理的架构中，BSS段（bss  segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block  Started  by  Symbol的简称。BSS段属于静态内存分配

 

 

**34****。线程与进程的区别和联系****?** **线程是否具有相同的堆栈****? dll****是否有独立的堆栈****?** 

答案：进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。每个线程有自己的堆栈。 DLL中有没有独立的堆栈，这个问题不好回答，或者说这个问题本身是否有问题。因为DLL中的代码是被某些线程所执行，只有线程拥有堆栈，如果DLL中的代码是EXE中的线程所调用，那么这个时候是不是说这个DLL没有自己独立的堆栈？如果DLL中的代码是由DLL自己创建的线程所执行，那么是不是说DLL有独立的堆栈？以上讲的是堆栈，如果对于堆来说，每个DLL有自己的堆，所以如果是从DLL中动态分配的内存，最好是从DLL中删除，如果你从DLL中分配内存，然后在EXE中，或者另外一个DLL中删除，很有可能导致程序崩溃

21：进程和线程的区别：

​    1：调度：线程作为调度和分配的基本单元，进程作为拥有资源的基本单位；

   2：并发性：不仅进程可以并发执行，同一进程内的线程也可以并发执行。

   3：拥有资源：进程是拥有资源的基本独立单元，线程不拥有资源，但可以访问进程内的资源；

​    4：在创建或撤销线程时，由于系统都要为之分配和回收内存资源，导致系统的开销明显大于创建或撤销线程时的开销。

**网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别？**

1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。

2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

两者都可以提高程序的并发度，提高程序运行效率和响应时间。

线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

 

 

2.TCP/IP通信建立的过程怎样，端口有什么作用？

答案：三次握手，确定是哪个应用程序使用该协议

 

1、局部变量能否和全局变量重名？

答案：能，局部会屏蔽全局。要用全局变量，需要使用"::" 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内

 

2、如何引用一个已经定义过的全局变量？

答案：extern 可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错

 

3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？

答案：可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错

 

4、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？

答案：全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。 static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件 static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝

2、程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。

1.介绍一下STL，详细说明STL如何实现vector。 

   STL (标准模版库，Standard Template Library)它由容器算法迭代器组成。 

   STL有以下的一些优点： 

   可以方便容易地实现搜索数据或对数据排序等一系列的算法； 

   调试程序时更加安全和方便； 

   即使是人们用STL在UNIX平台下写的代码你也可以很容易地理解（因为STL是跨平台的）。 

   vector实质上就是一个动态数组，会根据数据的增加,动态的增加数组空间。

 

 

 

4.指针和引用有什么分别；如果传引用比传指针安全，为什么？如果我使用常量指针难道不行吗？
   (1) 引用在创建的同时必须初始化，即引用到一个有效的对象；而指针在定义的时候不必初始化，可以在定义后面的任何地方重新赋值．
   (2) 不存在ＮＵＬＬ引用，引用必须与合法的存储单元关联;而指针则可以是NULL.
   (3) 引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用；而指针在任何时候都可以改变为指向另一个对象．给引用赋值并不是改变它和原始对象的绑定关系．
   (4) 引用的创建和销毁并不会调用类的拷贝构造函数
   (5) 语言层面，引用的用法和对象一样；在二进制层面，引用一般都是通过指针来实现的，只不过编译器帮我们完成了转换.
   不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，显得很安全。
   const 指针仍然存在空指针，并且有可能产生野指针.
   总的来说：引用既具有指针的效率，又具有变量使用的方便性和直观性．

 5.参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么；
   传值，传指针或者引用

8.C++和C定义结构的分别是什么。
   C language 的结构仅仅是数据的结合
   C plus plus的struct 和 class 其实具备几乎一样的功能，只是默认的访问属性不一样而已。

 9.构造函数可否是虚汗数，为什么？析构函数呢，可否是纯虚的呢？
   构造函数不能为虚函数，要构造一个对象，必须清楚地知道要构造什么，否则无法构造一个对象。
   析构函数可以为纯虚函数。

 10.拷贝构造函数相关问题，深拷贝，浅拷贝，临时对象等。
   深拷贝意味着拷贝了资源和指针，而浅拷贝只是拷贝了指针，没有拷贝资源
   这样使得两个指针指向同一份资源，造成对同一份析构两次，程序崩溃。
   临时对象的开销比局部对象小些

14.C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。
   多态的基础是继承，需要虚函数的支持，简单的多态是很简单的。
   子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数等等

 15.为什么要引入抽象基类和纯虚函数？
   主要目的是为了实现一种接口的效果。

18.多重继承如何消除向上继承的二义性。

   使用虚拟继承即可

19.关于数组

函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。

数组名的本质如下：
 （1）数组名指代一种数据结构，这种数据结构就是数组；

（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、自减等操作，不能被修改；

（3）数组名作为函数形参时，沦为普通指针。

20.关于宏

 （1）谨慎地将宏定义中的“参数”和整个宏用括弧括起来

（2）防止宏的副作用，会进行自增操作 

\21. void的作用在于：
 　（1） 对函数返回的限定；
 　（2） 对函数参数的限定

void的含义
 　void的字面意思是“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据。
 　void几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个void变量，void定义变量没有什么意义

\22. 关于联合

\1. 联合说明和联合变量定义
 联合也是一种新的数据类型, 它是一种特殊形式的变量。联合说明和联合变量定义与结构十分相似

联合表示几个变量公用一个内存位置, 在不同的时间保存不同的数据类型 和不同长度的变量

当一个联合被说明时, 编译程序自动地产生一个变量, 其长度为联合中最大的变量长度

联合访问其成员的方法与结构相同。同样联合变量也可以定义成数组或指针,但定义为指针时, 也要用"->;"符号, 此时联合访问成员可表示成:联合名->;成员名

联合既可以出现在结构内, 它的成员也可以是结构

 

\2. 结构和联合的区别
  \1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合转只存放了一个被选中的成员, 而结构的所有成员都存在。
  \2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的

 

**23.****关于程序的内存分配****
**   一个由c/C++编译的程序占用的内存分为以下几个部分
   1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
   2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表
   3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放
   4、文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放
   5、程序代码区—存放函数体的二进制代码。

**二、堆和栈的理论知识**
 **2.1****申请方式****
** stack:由系统自动分配。系统自动在栈中为其开辟空间
 heap:需要程序员自己申请，并指明大小，在c中malloc函数中或者在C++中用new运算符中其本身是在栈中的。
 **2.2****申请后系统的响应**
 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

 **2.4****申请效率的比较**
 栈由系统自动分配，速度较快。但程序员是无法控制的。
 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
 另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。

 **2.5****堆和栈中的存储内容**
 栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

 **2.6****存取效率的比较**
 在栈上的数组里的元素是在运行时刻赋值的；在堆上的指针所指向的元素是在编译时就确定的；但是，在以后的存取中，在栈上的数组比指针所指向的元素(例如堆)快。

数组在读取时直接就把数组里的元素读到寄存器cl中，而指针则要先把指针值读到edx中，在根据edx读取元素，显然慢了。
 **2.7****小结**
 堆和栈的区别：
 使用栈直接发出申请就可以使用快捷，但是自由度小。使用堆自由度大。

 

2．Heap与stack的差别。

Heap是堆，stack是栈。

Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。

Stack空间有限，Heap是很大的自由存储区

 

4、队列和栈有什么区别？

队列先进先出，栈后进先出

 

**三．****windows****进程中的内存结构：**

进程的内存空间而言，可以在逻辑上分成3个部份：代码区，静态数据区和动态数据区。

全局变量(Global)、本地变量(Local)，静态变量(Static)每种变量不同的分配方式：

全局变量和静态变量分配在静态数据区，

本地变量分配在动态数据区，即堆栈中，程序通过堆栈的基地址和偏移量来访问本地变量。

本地变量和全局变量分配的内存地址差了十万八千里，全局变量和静态变量分配的内存是连续的，注：、寄存器变量(Regeister)保存在CPU上。

动态数据区一般就是“堆栈”。“栈 (stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。

一个堆栈可以通过“基地址”和“栈顶”地址来描述。

├———————┤低端内存区域
 │ …… │
 ├———————┤
 │ 动态数据区 │
 ├———————┤
 │ …… │
 ├———————┤
 │ 代码区 │
 ├———————┤
 │ 静态数据区 │
 ├———————┤
 │ …… │
 ├———————┤高端内存区域

 

 

堆栈是一个先进后出的数据结构，栈顶地址总是小于等于栈的基地址

windows API的调用规则和ANSI C的函数调用规则是不一样的，前者由被调函数调整堆栈，后者由调用者调整堆栈。两者通过“__stdcall”和“__cdecl”前缀区分。

├———————┤<—函数执行时的栈顶（ESP）、低端内存区域
 │ …… │
 ├———————┤
 │ var 1 │
 ├———————┤
 │ var 2 │
 ├———————┤
 │ var 3 │
 ├———————┤
 │ RET │
 ├———————┤<—“__cdecl”函数返回后的栈顶（ESP）ANSI C
 │ parameter 1 │
 ├———————┤
 │ parameter 2 │
 ├———————┤
 │ parameter 3 │
 ├———————┤<—“__stdcall”函数返回后的栈顶（ESP）windows API
 │ …… │
 ├———————┤<—栈底（基地址 EBP）、高端内存区域

函数调用过程中堆栈的

 

new关键字分配的内存即不在栈中，也不在静态数据区

VC编译器是通过windows下的“堆(heap)”来实现new关键字的内存动态分配。在讲“堆”之前，先来了解一下和“堆”有关的几个API函数：

 HeapAlloc 在堆中申请内存空间
 HeapCreate 创建一个新的堆对象
 HeapDestroy 销毁一个堆对象
 HeapFree 释放申请的内存
 HeapWalk 枚举堆对象的所有内存块
 GetProcessHeap 取得进程的默认堆对象
 GetProcessHeaps 取得进程所有的堆对象
 LocalAlloc
 GlobalAlloc

当进程初始化时，系统会自动为进程创建一个默认堆，这个堆默认所占内存的大小为1M。堆对象由系统进行管理，它在内存中以链式结构存在。
 内存中的数据对齐。所位数据对齐，是指数据所在的内存地址必须是该数据长度的整数倍，DWORD数据的内存起始地址能被4除尽，WORD数据的内存起始地址能被2除尽

堆栈是一种简单的数据结构，是一种只允许在其一端进行插入或删除的线性表。允许插入或删除操作的一端称为栈顶，另一端称为栈底，对堆栈的插入和删除操作被称为入栈和出栈。有一组CPU指令可以实现对进程的内存实现堆栈访问。其中，POP指令实现出栈操作，PUSH指令实现入栈操作。CPU的ESP寄存器存放当前线程的栈顶指针，EBP寄存器中保存当前线程的栈底指针。CPU的EIP寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从 EIP寄存器中读取下一条指令的内存地址，然后继续执行

[堆和栈的区别](http://www.cnitblog.com/zouzheng/articles/39232.html)

堆（Heap）栈（Stack） 

**1****、内存分配方面：** 

  堆：一般由**程序员**分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下：**new**、**malloc**、**delete**、**free**等等。 

  栈：由**编译器**(Compiler)自动分配释放，存放**函数的参数值**，**局部变量**的值等。其操作方式类似于数据结构中的栈。 

**2****、申请方式方面：** 

  堆：需要程序员自己申请，并指明大小。在c中malloc函数如p1 = (char *)malloc(10)；在C++中用new运算符，但是注意p1、p2本身是在栈中的。因为他们还是可以认为是局部变量。 

  栈：由系统自动分配。 例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。 

**3****、系统响应方面：** 

  堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 

  栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 

**4****、大小限制方面：** 

  堆：是**向高地址扩展**的数据结构，是**不连续**的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中**有效的虚拟内存**。由此可见，堆获得的空间比较灵活，也比较大。 

  栈：在Windows下, 栈是**向低地址扩展**的数据结构，是一块**连续**的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是**系统预先规定好**的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 

**5****、效率方面：** 

  堆：是由new分配的内存，一般速度比较慢，而且**容易产生内存碎片**，不过用起来最**方便**，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。 

  栈：由系统自动分配，速度较快。但程序员是**无法控制**的。 

**6****、存放内容方面：** 

  堆：一般是在堆的头部用一个字节存放堆的大小。**堆中的具体内容有程序员安排。** 

  栈：在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的**地址**然后是函数的各个参数，在大多数的C编译器中，**参数是由右往左入栈**，然后是函数中的局部变量。 **注意****:** **静态变量是不入栈的**。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，**程序由该点继续运行**。 

**7****、存取效率方面：** 

  堆：char *s1 = "Hellow Word"；是在**编译时**就确定的； 

栈：char s1[] = "Hellow Word"； 是在**运行时**赋值的；用数组比用指针速度要快一些，因为指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上直接读取。

**1.****类成员函数的重载、覆盖和隐藏区别？**

**答案：a.成员函数被重载的特征：
 （1）相同的范围（在同一个类中）；
 （2）函数名字相同；
 （3）参数不同；
 （4）virtual 关键字可有可无。
 b.覆盖是指派生类函数覆盖基类函数，特征是：
 （1）不同的范围（分别位于派生类与基类）；
 （2）函数名字相同；
 （3）参数相同；
 （4）基类函数必须有virtual 关键字。**
 **c.****“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
 （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）**

 

**6.****软件测试都有那些种类?**

黑盒：针对系统功能的测试 白合：测试函数功能，各函数接口

2.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?

c用宏定义，c++用inline

3.直接链接两个信令点的一组链路称作什么?

PPP点到点连接

 

C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。

程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行

 

2.如果用VC开发程序，常见这么几个错误，C2001,c2005,c2011,这些错误的原因是什么。

在学习VC++的过程中，遇到的LNK2001错误的错误消息主要为：

 unresolved external symbol “symbol”（不确定的外部“符号”）。

如果连接程序不能在所有的库和目标文件内找到所引用的函数、变量或标签，将产生此错误消息。

 一般来说，发生错误的原因有两个：一是所引用的函数、变量不存在、拼写不正确或者使用错误；其次可能使用了不同版本的连接库。 

   编程中经常能遇到LNK2005错误——重复定义错误，其实LNK2005错误并不是一个很难解决的错误.

3.继承和委派有什么分别，在决定使用继承或者委派的时候需要考虑什么。 

   在OOD,OOP中，组合优于继承.

   当然多态的基础是继承，没有继承多态无从谈起。 

   当对象的类型不影响类中函数的行为时，就要使用模板来生成这样一组类。 

   当对象的类型影响类中函数的行为时，就要使用继承来得到这样一组类.

6.结合一个项目说明你怎样应用设计模式的理念。 

   设计模式更多考虑是扩展和重用，而这两方面很多情况下，往往会被忽略。 

   不过，我不建议滥用设计模式，以为它有可能使得简单问题复杂化.

7.介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）

   设计模式概念是由建筑设计师Christopher Alexander提出:"每一个模式描述了一个在我们周围不断重复发生的问题,以及该问题的解决方案的核心.这样,你就能一次又一次地使用该方案而不必做重复劳动."上述定义是对设计模式的广义定义.将其应用到面向对象软件的领域内,就形成了对设计模式的狭义定义.

   可以简单的认为:设计模式就是解决某个特定的面向对象软件问题的特定方法， 并且已经上升到理论程度。 

   框架与设计模式的区别:

   1,设计模式和框架针对的问题域不同.设计模式针对面向对象的问题域;框架针对特定业务的问题域 

   2,设计模式比框架更为抽象.设计模式在碰到具体问题后,才能产生代码;框架已经可以用代码表示 

   3,设计模式是比框架更小的体系结构元素.框架中可以包括多个设计模式 

   设计模式就像武术中基本的招式.将这些招式合理地纵组合起来,就形成套路(框架)，框架是一种半成品.

14.C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。 

   多态的基础是继承，需要虚函数的支持，简单的多态是很简单的。 

   子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数等等

15.为什么要引入抽象基类和纯虚函数？ 

   主要目的是为了实现一种接口的效果。 

16.介绍一下模板和容器。如何实现？（也许会让你当场举例实现） 

   模板可以说比较古老了，但是当前的泛型编程实质上就是模板编程。 

   它体现了一种通用和泛化的思想

17.你如何理解MVC。简单举例来说明其应用。 

   MVC模式是observer 模式的一个特例,典型的有MFC里面的文档视图架构。 

18.多重继承如何消除向上继承的二义性。 

   使用虚拟继承即可.

6，参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么；

   传值，传指针或者引用

 

 



# 美团笔试

```
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

//最小的投票数

int IsSqure(int target)
{
	for (int i=0;i<100000;i++)
	{
		if (i*i == target)
		{
			return 0;
		}
		if (i*i> target)
		{
			int left = abs(target-i*i);
			int right = abs(target-(i-1)*(i-1));
			if (left > right)
				return right;
			else
				return left;
		}
	}
	return 0;
}

int Test(vector<int> vi)
{
	std::sort(vi.begin(), vi.end());

	int size = vi.size();
	vector<int> addchanges;
	
	for (auto i=0u;i< size;++i)
	{
		if (IsSqure(vi[i]) == 0)
		{
			addchanges.push_back(0);
		}
		else
		{
			addchanges.push_back(IsSqure(vi[i]));
		}
	}
	
	sort(addchanges.begin(), addchanges.end());
	int half = size / 2;
	int res = 0;
	for (auto i = 0u; i < half; ++i)
	{
		res += addchanges[i];
	}
	return res;

}

int main() {
	//freopen("1.in","r",stdin);
	/*int n, ans = 0;
	cin >> n;
	vector<int> vi;
	for (int i = 0; i < n; i++) {
		int x;
		scanf_s("%d", &x);
		vi.push_back(x);
	}
	int res = Test(vi);
	cout << res << endl;*/
	int a = 8;
	double res = sqrt(a);
	cout << res << endl;
	return 0;
}
```



```
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>

using namespace std;

//i<j<k  a[i]<a[j]<a[k] 
//b[i]+b[j]+b[k]

//暴力解法
int Test(vector<int> va, vector<int> vb)
{
	int res = INT_MAX;
	for (size_t i=0;i< va.size();++i)
	{
		for (size_t j = i+1; j < va.size(); ++j)
		{
			for (size_t k = j + 1; k < va.size(); ++k)
			{
				if (va[k]>=va[j] && va[j]>=va[i])
				{
					int sum = vb[i] + vb[j] + vb[k];
					if (sum < res)
					{
						res = sum;
					}
				}
				else
				{
					continue;
				}
			}
		}
	}
	return res;
}

int main()
{
	int n, ans = 0;
	cin >> n;
	vector<int> va, vb;
	for (int j = 0; j < n; j++)
	{
		int x;
		scanf_s("%d", &x);
		va.push_back(x);
	}
	for (int j = 0; j < n; j++)
	{
		int x;
		scanf_s("%d", &x);
		vb.push_back(x);
	}

	int res = Test(va, vb);
	std::cout << res << std::endl;
	return 0;

}
```



```
#include <iostream>
#include <string>
#include <unordered_map>

//流，模拟；
int Test(const std::string &s, const std::string &a)
{
	//55%
	//abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz
	//             _                 _   _          __      _            _
	//meituan

	//12+13+4+3+10+5+12+12
	//25 + 4 +3+10+5+12
	if (a.empty())
		return 0;
	std::unordered_map<char, int> mci;
	int index = 0;
	for (auto ch:s)
	{
		mci.insert({ch,index});
		++index;
	}
	
	int res = 0;
	int lastpos = mci[a[0]];
	res += lastpos;
	//int lastpos = 0;
	for (auto ch:a)
	{
		int pos = mci[ch];
		if(pos == lastpos)
		{
			lastpos = pos;
			continue;
		}
		if (pos> lastpos)
		{
			res+=(pos - lastpos-1);
		}
		else
		{
			res += (mci.size()-1 - lastpos);
			res += pos;
		}
		lastpos = pos;
	}
	
	return res;

}

int main()
{
	std::string s;
	std::string a;
	std::cin >> s;
	std::cin >> a;
	int res = Test(s,a);
	std::cout << res << std::endl;
}
```





```
#include <iostream>
#include <set>

int main()
{
	std::multiset<int> msi1;
	std::multiset<int> msi2;
	int n = 0, m = 0;
	std::cin >> n >> m;
	for (int i=0;i<n;++i)
	{
		int a = 0;
		std::cin >> a;
		msi1.insert(a);
	}

	for (int i = 0; i < n; ++i)
	{
		int a = 0;
		std::cin >> a;
		msi2.insert(a);
	}
	
	bool find = true;
	int res = 0;
	for (int i=0;i<INT_MAX;++i)
	{
		for (auto begin1 = msi1.begin(), begin2 = msi2.begin(); begin1 != msi1.end() && begin2 != msi2.end(); begin1++, begin2++)
		{
			if ((*begin1 + i) % m != *begin2)
			{
				find = false;
				break;
			}
		}
		if (find)
		{
			res = i;
			break;
		}
		find = true;
	}
	
	std::cout << res << std::endl;
	return 0;

}
```



```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
	//5 3 4
	//5 8 3 10 7
	vector<int> vi;
	int n = 0, m = 0,c=0;
	std::cin >> n >> m>>c;
	for (int i = 0; i < n; ++i)
	{
		int a = 0;
		std::cin >> a;
		vi.push_back(a);
	}

	double ans = INT_MAX;
	for (int i=0;i<n;++i)
	{
		int j = i;
		int res = 0;
		for (int k=0;k<m;++k)
		{
			double tmp = vi[j] / (float)c;
			res += tmp;
			j++;
		}
		if (res<ans)
		{
			ans = res;
		}
	}
	
	std::cout << int(ans +0.5) << std::endl;
	return 0;

}
```



```
#include <iostream>
#include <vector>
using namespace std;
int main() {
	int n, m;
	cin >> n >> m;// 注意，如果输入是多个测试用例，请通过while循环处理多个测试用例
	vector<int> dp(n+1,0);
	if (m==1)
	{
		cout << 1 << endl;
	}
	else
	{
		dp[0] = 1, dp[1] = 1, dp[2] = 2;
		for (int i=3;i<=n;i++)
		{
			for (int j=1;j<m;++j)
			{
				if (i>j)
				{
					if (dp[i]!=dp[i-1] && dp[i] != dp[i - 2])
					{
						dp[i] += dp[i - j];
					}
					

				}
				else
				{
					if (dp[i] != dp[i - 1] && dp[i] != dp[i - 2])
					{
						dp[i] += dp[i - j];
					}
				}
				
			}
			
		}
	}
	cout << dp[n] << endl;

}
```



```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

void Test()
{
	int n, ans = 0;
	cin >> n;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			int x; scanf("%d", &x);
			ans += x;
		}
	}
	cout << ans << endl;
}

vector<int> MinNums(const vector<int>& vi, int full)
{
	unordered_map<int, int> mii;
	for (int i = 0; i < vi.size(); ++i)
	{
		mii.insert({ vi[i],i });
	}
	vector<int> res;
	vector<int> tmp = vi;
	sort(tmp.begin(), tmp.end());
	int eatnums = 0;
	bool find = false;
	for (int k= tmp.size()-1;k>=0;--k)
	{
		eatnums += tmp[k];
		res.push_back(mii[tmp[k]]+1);
		if (eatnums>= full)
		{
			find = true;
			break;
		}
	}
	if (find)
	{
		return res;
	}
	else
	{
		return {};
	}
}

int main() {
	

	int testnums, ans = 0;
	cin >> testnums;
	vector<vector<int>> vvi;
	vector<int> vfull;
	for (int i = 0; i < testnums; i++) {
		int deliciousnums = 0, full = 0;
		cin >> deliciousnums >> full;
		vector<int> vi;
		for (int k=0;k< deliciousnums;k++)
		{
			int x; 
			scanf("%d", &x);
			vi.push_back(x);
		}
		vvi.push_back(vi);
		vfull.push_back(full);
	}
	
	for (int i=0;i< vfull.size();++i)
	{
		vector<int> res = MinNums(vvi[i], vfull[i]);
		
		if (res.empty())
		{
			if (i != 0)
			{
				cout << endl;
			}
			cout << -1;
			continue;
		}
		int size = res.size();
		cout << size << endl;
		for (int j=0;j< size;++j)
		{
			cout << res[j]<<" ";
		}
		//cout << endl;
	}
	
	return 0;

}
```



```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

vector<int> GetMoreNums( vector<int> vi1,  vector<int> vi2)
{
	vector<int> res;
	unordered_map<int, int> mii;
	for (int i = 0; i < vi2.size(); ++i)
	{
		mii.insert({ vi2[i],i });
	}
	sort(vi1.begin(), vi1.end());
	sort(vi2.begin(), vi2.end());
	for (int k = 0; k < vi1.size(); ++k)
	{
		bool find = false;
		for (int i = 0; i < vi2.size(); ++i)
		{
			if (vi1[k]<vi2[i])
			{
				find = true;
				res.push_back(mii[vi2[i]] + 1);
				vi2.erase(vi2.begin() + i);
				break;
			}
		}
		if (!find)
		{
			res.push_back(-1);
		}
	}
	return res;
}

int main()
{
	int testnums, ans = 0;
	cin >> testnums;
	vector<vector<int>> vvi1;
	vector<vector<int>> vvi2;
	for (int i = 0; i < testnums; i++) {
		int friendnums = 0, actornums = 0;
		cin >> friendnums >> actornums;
		vector<int> vi1;
		vector<int> vi2;
		for (int k = 0; k < friendnums; k++)
		{
			int x;
			scanf("%d", &x);
			vi1.push_back(x);
		}
		for (int k = 0; k < actornums; k++)
		{
			int x;
			scanf("%d", &x);
			vi2.push_back(x);
		}
		vvi1.push_back(vi1);
		vvi2.push_back(vi2);
	}
	for (int i = 0; i < vvi1.size(); ++i)
	{
		vector<int> res = GetMoreNums(vvi1[i], vvi2[i]);
		for (auto i:res)
		{
			cout << i << " ";
		}
	}
}
```

