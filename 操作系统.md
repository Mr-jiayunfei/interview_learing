# 操作系统

## 什么是操作系统

比较常用的操作系统有windows操作系统、linux操作系统、macos操作系统

操作系统其实就是一个软件，控制和管理整个计算机系统的硬件和软件资源（系统资源的管理者）

向上，为应用程序提供了简单易用的接口，将硬件功能进行了封装

向下，管理着硬件资源，让各种硬件能够相互协调配合，实现更多更复杂的功能

操作系统的两个最基本特征是并发和共享，并发是指多个程序在同一个时间间隔内发生，宏观是上同时发生的，微观上是交替发生的

共享是指系统中的资源可以让多个进程共同使用。



## 什么是内核

内核是操作系统最重要最核心的部分，也是最接近硬件的部分，甚至可以说，一个操作系统只要有内核就够了(eg:Docker—>仅需Linux内核) 操作系统的功能未必都在内核中，如图形化用户界面 GUI

![image-20210723154109206](../markdown_note/校招/image-20210723154109206.png)

## 内核程序 VS 应用程序

普通程序员写的程序就是应用程序

微软、苹果有一帮人负责实现操作系统，他们写的就是内核程序

程序运行的过程就是CPU执行一条一条机器指令的过程（一条高级语言的代码翻译过来可能会对应多条机器指令）

## 特权指令 VS 非特权指令

在cpu设计和生产的时候就划分了特权指令和非特权指令，因此cpu执行一条指令前就能判断出指令类型

应用程序只能使用非特权指令，如加法指令、减法指令等

操作系统作为内核的管理者，有时会让cpu执行一些特权指令，如：内存清零指令，这些指令影响重大，只允许操作系统内核来使用

## 内核态 VS 用户态

cpu如何区分此时正在运行的程序是内核程序还是应用程序？

cpu有两种状态，内核态和用户态

处于内核态时，说明此时正在运行的是内核程序，可以执行特权指令（也可以执行非特权指令）

处于用户态时，说明此时正在运行的是用户程序，此时只能执行非特权指令

cpu有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示内核态，0表示用户态

内核态=核心态=管态

用户态=目态

## 内核态和用户态的切换

内核态->用户态：执行一条特权指令，修改psw（程序状态字寄存器）的标志位为用户态，这个动作意味着操作系统主动让出cpu使用权

用户态->内核态：由中断引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回cpu的使用权

1. 刚开机时，CPU 为“内核态”，操作系统内核程序先上CPU运行

2. 开机完成后，用户可以启动某个应用程序

3. 操作系统内核程序在合适的时候主动让出 CPU，让该应用程序上CPU运行 

   （操作系统内核在让出 CPU之前，会用一条特 权指令把 PSW 的标志位 设置为“用户态”）

4. 应用程序运行在用户态

5. 此时，一位猥琐黑客在应用程序中植入了一条特权指令，企图破坏系统... 

6. CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态” 

7. 这个非法事件会引发一个中断信号

   （CPU检测到中断信号后，会立即变为“核心态”，并停止运 行当前的应用程序，转而运行处理中断信号的内核程序）

8. “中断”使操作系统再次夺回CPU的控制权

9. 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序

## 中断和异常

中断会使cpu由用户态变为内核态，使操作系统重新夺回对cpu的使用权

中断是让操作系统内核夺回cpu使用权的唯一途径

如果没有中断机制，那么一旦应用程序上cpu执行，cpu就会一直运行这个应用程序

中断：

​	内中断（异常、例外）：与当前执行的指令有关，中断信号来自cpu内部

		1. 陷阱（陷入、trap）：由陷入指令引发，是应用程序故意引发的（系统调用）
		2. 故障（fault）：由错误条件引起的，可能被内核程序修复，内核程序修复故障后会把cpu使用权还给应用程序，让它继续执行下去（缺页中断、缺页故障）
		3. 终止（abort）：由致命错误引起，内核程序无法修复该错误，因此一般不再将cpu使用权还给应用程序，而是直接终止该应用程序，如：整数除0，非法使用特权指令等

外中断：与当前执行的指令无关，中断信号来自cpu外部

1. 时钟中断：时钟部件每隔一个时间片（如50ms）会给cpu发送一个时钟中断信号，操作系统内核决定让那一个应用程序上cpu运行
2. IO中断请求：当输入输出任务完成时，向cpu发送中断信号



## 中断机制基本原理

1. 检查中断信号：

内中断：cpu在执行指令时会检查是否有异常发生

外中断：每个指令周期末尾，cpu都会检查是否有外中断信号需要处理

2. 处理中断信号：

不同的中断信号，需要用不同的中断处理程序来处理，当cpu检测到中断信号后，会根据中断信号的类型去查询中断向量表，以此来找到相应的中断处理程序在内中的存放位置，中断处理程序一定是内核程序，需要运行在内核态

## 系统调用

系统调用是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务

## 系统调用与库函数

有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。

不是所有的库函数都是系统调用

不涉及系统调用的库函数:如的“取绝对值”的函数

涉及系统调用的库函数:如“创建一个新文件”的函数

## 系统调用使用场景

应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提 出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。

![image-20210713151635969](https://i.loli.net/2021/07/13/2FeXMw7ANdPacWh.png)

## 系统调用过程

如使用C语言，调用fork库函数（该库函数内部封装了系统调用的复杂细节），执行应用程序的过程，首先传递系统调用参数，将系统调用需要的参数放到某些通用寄存器中，执行陷入指令（fork函数），执行相应的内核请求程序处理系统调用，调用完成后返回应用程序

![image-20210713151929189](https://i.loli.net/2021/07/13/AHzrcqBC3Uiw4as.png)



## 程序

程序是静态的，就是存放在磁盘里面的可执行文件，是一系列的指令集和

## 进程

进程是动态的，是程序的一次执行过程，同一个程序多次执行会对应多个进程

## 进程的组成

进程的组成

PCB：PCB是进程存在的唯 一标志，当进程被创 建时，操作系统为其 创建PCB，当进程结 束时，会回收其PC

1. 进程描述信息：进程标识符PID，用户标识符UID
2. 进程控制和管理信息：CPU使用时间，磁盘使用情况，进程当前状态（就绪态/阻塞态/运行态）
3. 资源分配清单：正在使用哪些文件，正在使用哪些内存区域，正在使用哪些IO设备
4. 处理机相关信息：PSW，PC等各种寄存器的值（用户实现进程切换）

程序段：程序的代码（指令序列）

数据段：运行过程中产生的各种数据（如程序中定义的变量）

注：PCB是操作系统用的，程序段和数据段是进程自己用的

## 例子

同时挂三个QQ号，会对应三个QQ 进程，它们的PCB、数据段各不相 同，但程序段的内容都是相同的 (都是运行着相同的QQ程序)

## 进程特征

动态性：进程是程序的一次执行过程，是动态的产生、变化和消亡的

并发性：内存中有多个进程实体，各进程可以并发执行

独立性：进程是能独立运行，独立获得资源的基本单位

异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供进程同步机制来解决异步问题

结构性：每个进程都会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成

## 为什么进程是资源分配的基本单位

进程的PCB中保存了资源分配的清单，如正在使用哪些文件，正在使用哪些内存区域，正在使用哪些IO设备

如果以线程为资源分配的基本单位，同一个进程下的多个线程都有自己独立的资源，线程之间不能共享进程的地址空间

## 为什么线程是cpu调度的基本单位

如果cpu是4核，意味着同一时间可以有4个线程并行执行，假如是以进程为cpu调度的基本单位，一个进程有4个线程，当某一个线程执行完后，需要等待另外3个线程执行完，没有充分利用CPU资源；以线程为cpu调度的基本单位，线程执行完即可进行切换，不用考虑是同一个进程下的线程还是不同进程下的线程，可以充分利用cpu资源

## 进程基本操作

进程的创建（fork）：新创建的子进程得到与父进程相同的地址空间的一个副本，包括代码段、数据段等（PCB独立），子进程还获得父进程任何打开的文件的描述符副本，意味着子进程可以读写父进程打开的任何文件

进程的回收：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止

进程终止：exit函数



## 进程的状态转换

进程有5种状态，分别是创建状态、就绪态、运行态、阻塞态、终止状态。

当进程正在被创建时，它的状态时创建态，在这个阶段操作系统会为进程分配资源、初始化PCB

当进程创建完成后，进入就绪态，处于就绪态的进程已经具备运行条件，但是由于没有空闲的cpu，暂时不能运行

如果一个进程此时在CPU上运行，那么这个进程 处于“运行态”。 CPU会执行该进程对应的程序(执行指令序列)

在进程运行的过程中，可能会请求等待某个事件的发生(如等待 某种系统资源的分配，或者等待其他进程的响应)。 在这个事件发生之前，进程无法继续往下执行，此时操作系统会 让这个进程下CPU，并让它进入“阻塞态”

一个进程可以执行 exit 系统调用，请求操作系统终止该进程。 此时该进程会进入“终止态”，操作系统会让该进程下CPU， 并回收内存空间等资源，最后还要回收该进程的PCB。 当终止进程的工作完成之后，这个进程就彻底消失了。

进程PCB中，会有一个变量 state 来表示进程的当前状态。如:1表示创建态、2表示就绪态、3表示运行态... 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。（多个进程的组织方式有链接方式和索引方式）



![image-20210713164807164](../markdown_note/校招/image-20210713164807164.png)



## 进程切换

在进程切换时，首先修改当前运行的进程状态，保存运行环境（寄存器状态程序计数器、指令计数器、通用计数器等，将运行环境信息存入PCB种），然后将PCB移入相应队列，其次选择另一个进程执行，并更新起进程状态，最后根据PCB恢复进程所需要的运行环境

![image-20210713170153492](../markdown_note/校招/image-20210713170153492.png)

![image-20210713170216553](../markdown_note/校招/image-20210713170216553.png)



## 进程种类

孤儿进程：父进程退出，子进程还在运行的子进程是孤儿进程。孤儿进程将被init进程（1号进程）所收养，并由init进程对他们完成状态收集工作。

僵尸进程：进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。



## 进程和线程的区别和联系

1. 一个线程只能属于一个进程，而一个进程可以有多个线程
2. 进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间
3. 进程是资源分配的最小单位，线程是CPU调度的最小单位。
4. 进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。



## 进程通信

https://www.cnblogs.com/linuxbug/p/4872496.html

每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。

进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。

ipc:InterProcess Communication

![image-20210714165937724](https://i.loli.net/2021/07/14/7pbg5oRIzL1tuNW.png)

### 管道通信

#### **匿名管道(pipe)**

1. 管道是半双工的，数据只能向一个方向流动
2. 需要双方通信时，需要建立起两个管道
3. 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)
4. 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据
5. 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
6. 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
7. 如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。
8. 如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞
9. 如果管道发现另一端断开，将自动退出。

#### **有名管道(FIFO)**

1. 有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

2. 有名管道的名字存在于文件系统中，内容存放在内存中。

   （(以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信)）

3. 有名管道在打开时需要确实对方的存在，否则将阻塞

4. 以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞

5. 可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。(无名管道不可以)



### 共享内存通信

它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。

1. 共享内存是最快的一种通信方式，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。
2. 因为多个进程可以同时操作，所以需要进行同步处理。
3. 信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
4. 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。



### 信号通信

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 Linux 系统上支持的30 种不同类型的信号。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。

1. 发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：

- 内核检测到一个系统事件，比如除零错误或者子进程终止。

- —个进程调用了kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。


1. 接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号。



### 消息队列通信

1. 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
2. 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
3. 另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达

### Socket通信

套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。

https://www.jianshu.com/p/c1015f5ffa74

### 共享内存高效原因

https://www.jianshu.com/p/3ecf20200880

消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。

共享内存没有消息消息拷贝过程



## 线程

1. 线程是cpu调度的基本单位，可以实现进程内部的并发

2. 每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享进程的地址空间

3. 引入线程后，进程只作为除CPU之 外的系统资源的分配单元(如打 印机、内存地址空间等都是分配 给进程的)。 线程则作为处理机的分配单元

4. 传统的进程并发，需要切换进程的运行环境，系统开销很大；线程间并发，如果是同一个进程内的线程切换，则不需要切换进程环境，系统开销小

   

   

   ![image-20210715165638150](../markdown_note/校招/image-20210715165638150.png)

   



## 进程缺点

1. 进程在同一时刻只能做一个任务，很多时候不能充分利用CPU资源。
2. 进程在执行的过程中如果发生阻塞，整个进程就会挂起，即使进程中其它任务不依赖于等待的资源，进程仍会被阻塞。



## 进程VS 线程

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在

2. 进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间

   （资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）

3. 进程是资源分配的最小单位，线程是CPU调度的最小单位。

4. 进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。



## **多线程模型**

1. 多对一模型。将多个用户级线程映射到一个内核级线程上。

   优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

   缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。

2. 一对一模型。将内核线程与用户线程一一对应。

   优点：当一个线程被阻塞后，别的线程还可 以继续执行，并发能力强。多线程可在多核 处理机上并行执行

   缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到 核心态，因此线程管理的成本高，开销大。

   （linux和Windows操作系统家族都是使用一对一模型。）

3. 多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。



## 进程同步

1. 互斥锁
2. 读写锁
3. 条件变量
4. 自旋锁
5. 信号量



## 条件变量 VS 信号量

1. 使用条件变量可以一次唤醒所有等待者，而这个信号量没有这个功能
2. 信号量是有一个值（状态的），而条件变量是没有的，一个信号量可以是用mutex + counter + condition variable实现的

有了互斥锁和条件变量还提供信号量的原因是：“本标准提供信号量的而主要目的是提供一种进程间同步的方式；这些进程可能共享也可能不共享内存区。互斥锁和条件变量是作为线程间的同步机制说明的；这些线程总是共享(某个)内存区。这两者都是已广泛使用了多年的同步方式。每组原语都特别适合于特定的问题”。尽管信号量的意图在于进程间同步，互斥锁和条件变量的意图在于线程间同步，但是信号量也可用于线程间，互斥锁和条件变量也可用于进程间。应当根据实际的情况进行决定。信号量最有用的场景是用以指明可用资源的数量。

注：**互斥量是信号量的一种特例，互斥量的本质是一把锁**

## 线程同步

1. 互斥锁
2. 读写锁
3. 条件变量
4. 自旋锁
5. 信号量



## 自旋锁 VS 互斥锁 VS 读写锁

自旋锁条件不满足时，一直占用CPU，浪费资源

互斥锁条件不满足时，让出cpu

读写锁多个读者之间并不互斥，多个写者之间互斥

## **进程同步与线程同步有什么区别**

进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。而线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。



## 进程调度的时机

进程调度(低级调度)，就是按照某种算法从就绪队列中选择一个进程为其分配处理机。

当前运行的进程主动放弃处理机：

1. 进程正常终止
2. 运行过程中发生异常终止
3. 进程主动请求阻塞(如 等待I/O

当前运行的进程被动放弃处理机：

1. 分给进程的时间片用完
2. 有更紧急的事需要处理(如 I/O中断)
3. 有更高优先级的进程进入就绪队列



## 不能进程调度的情况

1. 在处理中断的过程中，
2. 进程在操作系统内核程序临界区中。
3. 在原子操作过程中(原语)。原子操作不可中断，要一气呵成(如 之前讲过的修改PCB中程序状态标志，并把PCB放到相应队列)



## 进程调度算法的评价指标

1. CPU利用率
2. 系统吞吐率，即单位时间内CPU完成的作业的数量。
3. 响应时间。
4. 周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键



## **进程的调度策略**

1. 先到先服务调度算法

2. 短作业优先调度算法

3. 高响应比优先算法

   ===上面一般是早期的批处理系统

4. 优先级调度算法：若源源不断地有高优先级进程到来，则可能导致饥饿

5. 时间片轮转调度算法：时钟中断，不区分优先级

6. 多级反馈队列调度算法

   ====一般用于交互式系统



## 死锁

在并发环境下，各进程因竞 争资源而造成的一种互相等 待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”

每个人都占有一个资源，同时又在等待另一个人手里的资源。发生“死锁”

产生条件：

1. 互斥条件:只有对必须互斥使用的资源的争抢才会导致死锁
2. 不剥夺条件:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
3. 请求和保持条件:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请 求进程被阻塞，但又对自己已有的资源保持不放
4. 循环等待条件:存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。



## 死锁预防策略

1. 破坏互斥条件：如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态

2. 破坏不剥夺条件：

   方案一:当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时
   再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。
   方案二:当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强
   行剥夺。这种方式一般需要考虑各进程的优先级(比如:剥夺调度方式，就是将处理机资源强行剥
   夺给优先级更高的进程使用)

3. 破坏请求和保持条件：即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，
   不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源
   了。

4. 破坏循环等待条件：规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源)一次申请完。

   原理分析:一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。

## 死锁避免策略

银行家算法，核心思想:在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进
入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

## 进程内存保护

方法一:在CPU中设置一对上、下限寄存器，存放 进程的上、下限地址。进程的指令要访问某个地址 时，CPU检查是否越界。

方法二:采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。



## 逻辑地址 VS 物理地址

逻辑地址又叫相对地址，物理地址又叫绝对地址

程序经过编译、链接 后生成的指令中指明 的是逻辑地址(相对 地址)，即:相对于 0 进程的起始地址而言的地址

物理地址是内存的真实地址



## 为什么要引入虚拟内存

传统存储管理有其局限性，不论是连续分配还是非连续分配，都有两个缺点：一次性和驻留性。

一次性:作业必须一次性全部装入内存后才能开始运行。这会造成两个问题:1作业很大时，不能全部装入内存，导致大作业无法运行;2当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。

驻留性:一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

又因为时间局部性和空间局部性原理，可以只将近期用到的数据放到内存中。

时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)
空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)



## 什么是虚拟内存



基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。

在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。

若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存

在操作系统的管理下，在用户看来似乎有一个比实际 内存大得多的内存，这就是虚拟内存



虚拟内存的最大容量是由计算机的地址结构(CPU寻址范围)确定的 

虚拟内存的实际容量 = min(内存和外存容量之和，CPU寻址范围)



## 虚拟内存特征

1. 多次性:无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
2. 对换性:在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
3. 虚拟性:从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

## 虚拟内存实现

是通过请求分页机制实现的

操作系统要提供请求调页(或请求调段)功能：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外
存调入内存，然后继续执行程序。

操作系统要提供页面置换(或段置换)的功能：若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。



## 请求分页管理方式

### 页表机制

与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存;如果还没调入，那么也需要知道该页面在外存中存放的位置。

当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面;有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。



![image-20210716110312082](../markdown_note/校招/image-20210716110312082.png)

### 缺页中断机制

在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。

此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。

如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。

如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，

若该页面在内存期间被修改过，则要将其写回外存。

未修改过的页面不用写回外存

缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。

 一条指令在执行期间，可能产生多次缺页中断。

(如:copy A to B，即将逻辑地址A中的数据复制到 逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)

### 地址变换机构

![image-20210716144635201](https://i.loli.net/2021/07/16/gYCeENaPytbS2xO.png)

查快表(未命中)——查慢表(发现未调入内存)——调页(调 入的页面对应的表项会直接加入快表)——查快表(命中)——访问目标内存单元



在进行地址变换时，先检索快表：

1 若找到要访问的页，则修改页表项中的访问位（写指令还需要重置修改位），然后利用页表项中给出的物理块号和页内地址形成物理地址

2 若没有找到该页的页表项，则应到内存中去查找页表，再对比页表项中的状态位P，看该页是否已经调入内存，未掉入则产生缺页中断，请求从外存把该页调入内存



![image-20210716145514889](https://i.loli.net/2021/07/16/6WZkXpdhP1E3UOt.png)

## 请求分页页面置换算法

 页面的换入、换出需要磁盘 I/O，会有较大的开销，因 此好的页面置换算法应该追 求更少的缺页率

![image-20210716145621133](https://i.loli.net/2021/07/16/zSkG4BgqwKVXr9Y.png)

最佳置换算法(OPT，Optimal):每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。
最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法􏰀前预判页面访问序列。因此，最佳置换算法是无法实现的。



先进先出置换算法(FIFO):每次选择淘汰的页面是最早进入内存的页面 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。 队列的最大长度取决于系统为进程分配了多少个内存块。



最近最久未使用置换算法(LRU，least recently used):每次淘汰的页面是最近最久未使用的页面 实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。 当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面



时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)
简单的CLOCK 算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成 一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。 如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫 􏰁中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描，第二轮扫描一定会 有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描



改进型的时钟置换算法：简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过， 就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。 因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他 条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。 修改位=0，表示页面没有被修改过;修改位=1，表示页面被修改过。

第一优先级:最近没访问，且没修改的页面，

第二优先级:最近没访问，但修改过的页面

第三优先级:最近访问过，但没修改的页面

第四优先级:最近访问过，且修改过的页面



## 软链接 VS 硬链接

软链接和硬链接都是为了文件共享

硬链接是基于索引结点的共享方式，一个文件名对应一个索引结点指针，

索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数

若 count = 2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。 若某个用户决定“删除”该文件，

则只是要把用户目录中与该文件对应的目录项删除，且索引结点的 count值减 1。

若 count>0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。 当 count = 0 时系统负责删除文件。

![image-20210723162003637](../markdown_note/校招/image-20210723162003637.png)

软链接是基于符号链的共享方式，文件类型是link类型

![image-20210723162050239](https://i.loli.net/2021/07/23/p9tdn2ixeKQuXvB.png)



windos的快捷方式属于软链接

ln -s a b创建软链接

lb a  b 创建硬链接



## 操作系统内存管理

从逻辑地址空间和物理地址空间开始阐述，

程序经过编译、链接后生成的指令中指明的是逻辑地址(相对地址)，即:相对于 0 进程的起始地址而言的地址

物理地址是内存的真实地址。

在传统的存储管理中，作业必须一次性全部装入内存才能开始运行，这会造成两个问题:1作业很大时，不能全部装入内存，导致大作业无法运行;2当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。同时一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

为了解决传统存储管理的弊端，引入了虚拟内存。

在操作系统的管理下，在用户看来似乎有一个比实际 内存大得多的内存，这就是虚拟内存

虚拟内存的实际容量 = min(内存和外存容量之和，CPU寻址范围)

虚拟内存是通过请求分页机制实现的。请求分页机制是通过页表机制、缺页中断机制、页面置换算法功能实现的



## 一个线程占多大内存



